// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGenerators.Library.Generator on 12/11/2023 14:23:13 +00:00
// </auto-generated>
#pragma warning disable

namespace RhoMicro.CodeAnalysis.UtilityGenerators;

using Microsoft.CodeAnalysis;
using System;
    
/// <summary>
/// Generates types from the <c>RhoMicro.CodeAnalysis.UtilityGenerators.Library</c> library into the target project.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class LibraryGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static c =>
        {
            c.AddSource(
    "CSharpBuilderFormattingOptions.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis.CSharp;

using System;
using System.Collections.Generic;

/// <summary>
/// Represents the settings used for formatting the c# output produced by an instance of <see cref="IExpandingMacroStringBuilder{TMacro}"/>.
/// </summary>
/// <param name="parseOptions">
/// The options to use when parsing the generated source text.
/// </param>
/// <param name="indentation">
/// An optional sequence of whitespace characters that defines a single level of
/// indentation.
/// </param>
/// <param name="endOfLine">
/// An optional sequence of whitespace characters used for end of line.
/// </param>
/// <param name="elasticTrivia">
/// If true the replaced trivia is elastic trivia.
/// </param>
readonly struct CSharpBuilderFormattingOptions(
    CSharpParseOptions parseOptions,
    String indentation = "\t",
    String endOfLine = "\r\n",
    Boolean elasticTrivia = false) : IEquatable<CSharpBuilderFormattingOptions>
{
    /// <summary>
    /// The default options.
    /// </summary>
    public static readonly CSharpBuilderFormattingOptions Default = new(CSharpParseOptions.Default);

    /// <summary>
    /// The options to use when parsing the generated source text.
    /// </summary>
    public CSharpParseOptions ParseOptions { get; } = parseOptions;
    /// <summary>
    /// An optional sequence of whitespace characters that defines a single level of
    /// indentation.
    /// </summary>
    public String Indentation { get; } = indentation;
    /// <summary>
    /// An optional sequence of whitespace characters used for end of line.
    /// </summary>
    public String EndOfLine { get; } = endOfLine;
    /// <summary>
    /// If true the replaced trivia is elastic trivia.
    /// </summary>
    public Boolean ElasticTrivia { get; } = elasticTrivia;

    /// <inheritdoc/>
    public override Boolean Equals(Object? obj) => obj is CSharpBuilderFormattingOptions options && Equals(options);
    /// <inheritdoc/>
    public Boolean Equals(CSharpBuilderFormattingOptions other) => EqualityComparer<CSharpParseOptions>.Default.Equals(ParseOptions, other.ParseOptions)
        && Indentation == other.Indentation
        && EndOfLine == other.EndOfLine
        && ElasticTrivia == other.ElasticTrivia;
    /// <inheritdoc/>
    public override Int32 GetHashCode()
    {
        var hashCode = -551825062;
        hashCode = hashCode * -1521134295 + EqualityComparer<CSharpParseOptions>.Default.GetHashCode(ParseOptions);
        hashCode = hashCode * -1521134295 + EqualityComparer<String>.Default.GetHashCode(Indentation);
        hashCode = hashCode * -1521134295 + EqualityComparer<String>.Default.GetHashCode(EndOfLine);
        hashCode = hashCode * -1521134295 + ElasticTrivia.GetHashCode();
        return hashCode;
    }
    public static Boolean operator ==(CSharpBuilderFormattingOptions left, CSharpBuilderFormattingOptions right) => left.Equals(right);
    public static Boolean operator !=(CSharpBuilderFormattingOptions left, CSharpBuilderFormattingOptions right) => !(left == right);
}

""");c.AddSource(
    "DiagnosticProvider.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

/// <summary>
/// Contains factory and extension methods for diagnostic providers.
/// </summary>
static partial class DiagnosticProvider
{
    /// <summary>
    /// Creates a new diagnostic provider.
    /// </summary>
    /// <typeparam name="TModel">The type of model to analyze.</typeparam>
    /// <param name="strategy">Th estrategy to utilize when diagnosing models.</param>
    /// <returns>A new diagnostic provider.</returns>
    public static IDiagnosticProvider<TModel> Create<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> strategy) =>
        new Strategy<TModel>(strategy);
    /// <summary>
    /// Creates a new diagnostic provider.
    /// </summary>
    /// <typeparam name="TModel">The type of model to analyze.</typeparam>
    /// <param name="strategy">Th estrategy to utilize when diagnosing models.</param>
    /// <returns>A new diagnostic provider.</returns>
    public static IDiagnosticProvider<TModel> Create<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>> strategy) =>
        new Strategy<TModel>((model, diagnostics, token) =>
        {
            token.ThrowIfCancellationRequested();
            strategy.Invoke(model, diagnostics);
        });
}
""");c.AddSource(
    "DiagnosticProvider.Strategy.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

partial class DiagnosticProvider
{
    internal sealed class Strategy<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> strategy) : IDiagnosticProvider<TModel>
    {
        private readonly Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> _strategy = strategy;

        public void Diagnose(TModel model, IDiagnosticsAccumulator<TModel> accumulator, CancellationToken cancellationToken = default) => 
            _strategy.Invoke(model, accumulator, cancellationToken);
    }
}
""");c.AddSource(
    "DiagnosticsAccumulator.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;

/// <summary>
/// Contains factory and extension methods for diagnostic accumulators.
/// </summary>
static partial class DiagnosticsAccumulator
{
    /// <summary>
    /// Creates a new diagnostic accumulator.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="model">The model to diagnose.</param>
    /// <returns>A new diagnostic accumulator.</returns>
    public static IDiagnosticsAccumulator<TModel> Create<TModel>(TModel model) =>
        new Impl<TModel>(model);

    /// <summary>
    /// Applies a filter to the diagnostic accumulator that discards all hidden diagnostics.
    /// This will prevent diagnostics from being added to the accumulator if they have a severity of <see cref="DiagnosticSeverity.Hidden"/>.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> DiagnoseNonHiddenSeverities<TModel>(this IDiagnosticsAccumulator<TModel> accumulator) =>
        accumulator
        .DiagnoseSeverity(DiagnosticSeverity.Info)
        .DiagnoseSeverity(DiagnosticSeverity.Warning)
        .DiagnoseSeverity(DiagnosticSeverity.Error);
    /// <summary>
    /// Applies a filter to the diagnostic accumulator that discards all diagnostics not registered to be diagnosed.
    /// This will prevent diagnostics from being added to the accumulator if they do not have a registered severity.
    /// Calls to this filter may be chained for registering a set of diagnosable severities.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <param name="severity">The diagnostics severity to register as diagnosable.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> DiagnoseSeverity<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, DiagnosticSeverity severity) =>
        accumulator is DiagnosisFilter<TModel> decorator ?
            decorator.AddSeverity(severity) :
            new DiagnosisFilter<TModel>(accumulator, severity);

    /// <summary>
    /// Receives diagnostics providers for generating diagnostics on the model.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="providers">The providers to generate diagnostics with.</param>
    /// <param name="accumulator">The accumulator to receive the providers.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference tothe accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> Receive<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, IEnumerable<IDiagnosticProvider<TModel>> providers, CancellationToken cancellationToken = default) =>
        providers.Aggregate(accumulator, (d, p) => d.Receive(p, cancellationToken));

    /// <summary>
    /// Applies a filter to the diagnostic accumulator that reports only non hidden diagnostics.
    /// This will cause diagnostics with the severity <see cref="DiagnosticSeverity.Hidden"/> not to be reported, however they will still be added to the accumulator.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> ReportNonHiddenSeverities<TModel>(this IDiagnosticsAccumulator<TModel> accumulator) =>
        accumulator
        .ReportSeverity(DiagnosticSeverity.Info)
        .ReportSeverity(DiagnosticSeverity.Warning)
        .ReportSeverity(DiagnosticSeverity.Error);
    /// <summary>
    /// Applies a filter to the diagnostic accumulator that reports only diagnostics with registered severities.
    /// This will cause diagnostics without a registered severity not to be reported, however they will still be added to the accumulator.
    /// Calls to this filter may be chained for registering a set of reportable severities.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <param name="severity">The diagnostics severity to register as reportable.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> ReportSeverity<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, DiagnosticSeverity severity) =>
        accumulator is ReportFilter<TModel> decorator ?
            decorator.AddSeverity(severity) :
            new ReportFilter<TModel>(accumulator, severity);
}

""");c.AddSource(
    "DiagnosticsAccumulator.DiagnosisFilter.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class DiagnosisFilter<TModel>(IDiagnosticsAccumulator<TModel> decoratedAccumulator, DiagnosticSeverity severity) : IDiagnosticsAccumulator<TModel>
    {
        private readonly IDiagnosticsAccumulator<TModel> _decoratedAccumulator = decoratedAccumulator;
        private readonly HashSet<DiagnosticSeverity> _severities = [severity];

        public IDiagnosticsAccumulator<TModel> AddSeverity(DiagnosticSeverity severity)
        {
            if(_severities.Contains(severity))
            {
                return this;
            }

            var result = new DiagnosisFilter<TModel>(_decoratedAccumulator, severity);
            foreach(var s in _severities)
            {
                _ = result._severities.Add(s);
            }

            return result;
        }

        public Boolean ContainsErrors => _decoratedAccumulator.ContainsErrors;

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic) =>
            _severities.Contains(diagnostic.Severity) ?
            _decoratedAccumulator.Add(diagnostic) :
            this;

        public void ReportDiagnostics(Action<Diagnostic> report) => _decoratedAccumulator.ReportDiagnostics(report);
        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            _ = _decoratedAccumulator.Receive(provider, cancellationToken);
            return this;
        }
    }
}

""");c.AddSource(
    "DiagnosticsAccumulator.Impl.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class Impl<TModel>(TModel model) :
    IDiagnosticsAccumulator<TModel>
    {
        private readonly List<Diagnostic> _diagnostics = [];
        private readonly TModel _model = model;

        public Boolean ContainsErrors { get; private set; }

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic)
        {
            _diagnostics.Add(diagnostic);

            if(diagnostic.Severity == DiagnosticSeverity.Error)
            {
                ContainsErrors = true;
            }

            return this;
        }

        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            provider.Diagnose(_model, this, cancellationToken);
            return this;
        }
        public void ReportDiagnostics(Action<Diagnostic> report)
        {
            foreach(var diagnostic in _diagnostics)
            {
                report.Invoke(diagnostic);
            }
        }
    }
}

""");c.AddSource(
    "DiagnosticsAccumulator.ReportFilter.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class ReportFilter<TModel>(IDiagnosticsAccumulator<TModel> decoratedAccumulator, DiagnosticSeverity severity) : IDiagnosticsAccumulator<TModel>
    {
        private readonly IDiagnosticsAccumulator<TModel> _decoratedAccumulator = decoratedAccumulator;
        private readonly HashSet<DiagnosticSeverity> _severities = [severity];

        public IDiagnosticsAccumulator<TModel> AddSeverity(DiagnosticSeverity severity)
        {
            if(_severities.Contains(severity))
            {
                return this;
            }

            var result = new ReportFilter<TModel>(_decoratedAccumulator, severity);
            foreach(var s in _severities)
            {
                _ = result._severities.Add(s);
            }

            return result;
        }

        public Boolean ContainsErrors => _decoratedAccumulator.ContainsErrors;

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic) => _decoratedAccumulator.Add(diagnostic);
        public void ReportDiagnostics(Action<Diagnostic> report) => _decoratedAccumulator.ReportDiagnostics(d =>
        {
            if(_severities.Contains(d.Severity))
            {
                report.Invoke(d);
            }
        });
        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            _ = _decoratedAccumulator.Receive(provider, cancellationToken);
            return this;
        }
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

/// <summary>
/// Represents an action appending to an expanding macro string builder.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <param name="builder">The builder to append to.</param>
/// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
delegate void Appendix<TMacro>(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken);

/// <summary>
/// Represents an action appending to an expanding macro string builder.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <typeparam name="TModel">The type of model to pass to the appendix.</typeparam>
/// <param name="builder">The builder to append to.</param>
/// <param name="model">The model to pass to the appendix.</param>
/// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
delegate void Appendix<TMacro, TModel>(IExpandingMacroStringBuilder<TMacro> builder, TModel model, CancellationToken cancellationToken);

/// <summary>
/// Contains factory and extension methods for expanding macro string builders.
/// </summary>
static partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Creates a new expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="providers">An optional collection of expansion providers to initialize the builder with.</param>
    /// <returns>A new expanding macro string builder.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Create<TMacro>(params IMacroExpansion<TMacro>[] providers) =>
        providers.Aggregate(Create<TMacro>(), static (b, w) => b.Receive(w, default));
    /// <summary>
    /// Creates a new expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <returns>A new expanding macro string builder.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Create<TMacro>() => Impl<TMacro>.Create();
    /// <summary>
    /// Applies an error intercepting proxy to an expanding macro string builder.
    /// Upon the diagnostics accumulator provided reporting errors, no further appendices 
    /// will be passed through to the underlying builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model diagnosed by the diagnostics.</typeparam>
    /// <param name="builder">The builder to apply error interception to.</param>
    /// <param name="diagnostics">The diagnostics based on which to intercept appendices.</param>
    /// <returns>A new reference to the proxy, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> InterceptErrors<TMacro, TModel>(this IExpandingMacroStringBuilder<TMacro> builder, IDiagnosticsAccumulator<TModel> diagnostics) =>
        ErrorProxy<TMacro, TModel>.Apply(builder, diagnostics);
    /// <summary>
    /// Applies a formatting decorator to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to apply formatting to.</param>
    /// <param name="options">The options to use when formatting.</param>
    /// <returns>A new reference to the decorator, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Format<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        CSharpBuilderFormattingOptions? options = null)
    {
        options ??= CSharpBuilderFormattingOptions.Default;

        if(builder is CSharpFormatter<TMacro> decorator)
        {
            return decorator.WithOptions(options.Value);
        }

        return new CSharpFormatter<TMacro>(builder, options.Value);
    }

    /// <summary>
    /// Registers a expansion provider to the builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to register the provider to.</param>
    /// <param name="macro">The macro to expansion text for using the provider registered.</param>
    /// <param name="strategy">The strategy using which to write expansion text to a string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Receive<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Receive(MacroExpansion.Create(macro, strategy), cancellationToken);
    }
    /// <summary>
    /// Registers a collection of expansion providers to the builder.
    /// </summary>
    /// <param name="builder">The builder to append expansion providers to.</param>
    /// <param name="providers">The providers to register.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Receive<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IEnumerable<IMacroExpansion<TMacro>> providers,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = providers ?? throw new ArgumentNullException(nameof(providers));

        foreach(var provider in providers)
        {
            builder = builder.Receive(provider, cancellationToken);
        }

        return builder;
        ;
    }
    /// <summary>
    /// Appends an appendix to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the appendix to.</param>
    /// <param name="appendix">The appendix to append to the builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Append<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Appendix<TMacro> appendix,
        CancellationToken cancellationToken)
    {
        appendix.Invoke(builder, cancellationToken);
        return builder;
    }
    /// <summary>
    /// Appends an appendix to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model to pass to the appendix.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="model">The model to pass to the appendix.</param>
    /// <param name="appendix">The appendix to append to the builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Append<TMacro, TModel>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Appendix<TMacro, TModel> appendix,
        TModel model,
        CancellationToken cancellationToken)
    {
        appendix.Invoke(builder, model, cancellationToken);
        return builder;
    }
    #region Append Value
    /// <summary>
    /// Appends to the builder a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append('\n');
    }
    /// <summary>
    /// Appends a generator marker attribute, as well as a pragma for dsabling all warnings to the builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the header to.</param>
    /// <param name="generatorName">The name of the generator, for adding a meaningful comment.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendHeader<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String generatorName)
        => builder.AppendLine("// <auto-generated>")
        .Append("// This file was last generated by the ").Append(generatorName).Append(" on ").AppendLine(DateTimeOffset.Now.ToString())
        .AppendLine("// </auto-generated>")
        .AppendLine("#pragma warning disable");
    /// <summary>
    /// Appends to the builder a string value, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="value">The value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String value)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append(value).AppendLine();
    }

    /// <summary>
    /// Appends to the builder a character value, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="value">The value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char value)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append(value).AppendLine();
    }

    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The string to use as a separator.</param>
    /// <param name="values">An enumeration containing values to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String separator,
        IEnumerable<T> values)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The character to use as a separator.</param>
    /// <param name="values">An enumeration containing values to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char separator,
        IEnumerable<T> values)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration. 
    /// A expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return values.Aggregate(builder, (b, e) => aggregation.Invoke(b, e, cancellationToken));
    }

    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// A expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The string to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// A expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The character to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    #endregion
    #region Append Macro
    /// <summary>
    /// Appends all values from an enumeration type macro to an expanding macro string builder.
    /// The macro values will be appended in ascending order.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append macros to.</param>
    /// <param name="comparer">The comparer to use when ordering macro values.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacros<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IComparer<TMacro> comparer,
        CancellationToken cancellationToken = default)
        where TMacro : struct, Enum
    {
        var result = Enum.GetValues(typeof(TMacro))
            .OfType<TMacro>()
            .OrderBy(m => m, comparer)
            .Aggregate(builder, (b, p) => b.AppendMacro(p, cancellationToken));

        return result;
    }
    /// <summary>
    /// Appends all values from an enumeration type macro to an expanding macro string builder.
    /// The macro values will be appended in ascending order.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append macros to.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacros<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        CancellationToken cancellationToken = default)
        where TMacro : struct, Enum => builder.AppendMacros(Comparer<TMacro>.Default, cancellationToken);
    /// <summary>
    /// Appends to the builder a macro, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="macro">The macro to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro macro,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.AppendMacro(macro, cancellationToken).AppendLine();
    }

    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The macro to use as a separator.</param>
    /// <param name="values">An enumeration containing macros to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro separator,
        IEnumerable<T> values,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.AppendMacro(separator, cancellationToken)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// A expanding macro string builder is used as the initial accumulator macro.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The macro to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.AppendMacro(separator, cancellationToken);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    #endregion
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.CSharpFormatter.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System;
using System.Collections.Generic;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Formats the build output of the decorated expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The expanding macro string builder to decorate.</param>
    /// <param name="options">The options to use when formatting generated source text.</param>
    internal sealed class CSharpFormatter<TMacro>(
        IExpandingMacroStringBuilder<TMacro> builder,
        CSharpBuilderFormattingOptions options) :
        IExpandingMacroStringBuilder<TMacro>,
        IEquatable<CSharpFormatter<TMacro>?>
    {
        private readonly IExpandingMacroStringBuilder<TMacro> _decoratedBuilder = builder;
        private readonly CSharpBuilderFormattingOptions _options = options;

        /// <summary>
        /// Creates a new formatting decorator decorating the same builder, but using the provided options.
        /// </summary>
        /// <param name="newOptions">The options to be used by the new formatting decorator.</param>
        /// <returns>A new formatting decorator.</returns>
        public CSharpFormatter<TMacro> WithOptions(CSharpBuilderFormattingOptions newOptions) =>
            new(_decoratedBuilder, newOptions);

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            _ = _decoratedBuilder.Append(value);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            _ = _decoratedBuilder.Append(value);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            _ = _decoratedBuilder.AppendMacro(macro, cancellationToken);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> writer, CancellationToken cancellationToken = default)
        {
            _ = _decoratedBuilder.Receive(writer, cancellationToken);

            return this;
        }

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default) =>
            CSharpSyntaxTree.ParseText(
                text: _decoratedBuilder.Build(cancellationToken),
                options: _options.ParseOptions,
                cancellationToken: cancellationToken)
                .GetRoot(cancellationToken)
                .NormalizeWhitespace(
                    indentation: _options.Indentation,
                    eol: _options.EndOfLine,
                    elasticTrivia: _options.ElasticTrivia)
                .SyntaxTree
                .GetText(cancellationToken)
                .ToString();
        /// <inheritdoc/>
        public override String ToString() => Build(default);
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) => Equals(obj as CSharpFormatter<TMacro>);
        /// <inheritdoc/>
        public Boolean Equals(CSharpFormatter<TMacro>? other) =>
            other is not null &&
            EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_decoratedBuilder, other._decoratedBuilder);
        /// <inheritdoc/>
        public override Int32 GetHashCode() => 1679842278 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_decoratedBuilder);
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.ErrorProxy.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Proxies operations on an expanding macro string builder against error diagnostics. 
    /// Operations will only be passed through if no errors have been diagnosed 
    /// to the diagnostics accumulator provided.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model whose diagnostics to query.</typeparam>
    /// <param name="proxied">The expanding macro string builder to proxy.</param>
    /// <param name="diagnostics">The diagnostics accumulator to query for errors when intercepting operations.</param>
    internal sealed class ErrorProxy<TMacro, TModel>(
        IExpandingMacroStringBuilder<TMacro> proxied,
        IDiagnosticsAccumulator<TModel> diagnostics) :
        IExpandingMacroStringBuilder<TMacro>,
        IEquatable<ErrorProxy<TMacro, TModel>?>
    {
        private readonly IExpandingMacroStringBuilder<TMacro> _proxied = proxied;
        private readonly IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default) => _proxied.Build(cancellationToken);
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.AppendMacro(macro, cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Receive(provider, cancellationToken);
            }

            return this;
        }
        /// <summary>
        /// Creates a new proxy for the builder provided, if it is not already an error proxy using the diagnostics provided.
        /// </summary>
        /// <param name="builder">The builder to conditionally proxy.</param>
        /// <param name="diagnostics">The diagnostics based on which to intercept appendices.</param>
        /// <returns>
        /// The new proxy if the builder provided is not already an error proxy using the diagnostics 
        /// provided; otherwise, a reference to the builder, for chaining of further method calls.
        /// </returns>
        public static IExpandingMacroStringBuilder<TMacro> Apply(IExpandingMacroStringBuilder<TMacro> builder, IDiagnosticsAccumulator<TModel> diagnostics)
        {
            if(builder is not ErrorProxy<TMacro, TModel> proxy || 
               !EqualityComparer<IDiagnosticsAccumulator<TModel>>.Default.Equals(proxy._diagnostics, diagnostics))
            {
                proxy = new ErrorProxy<TMacro, TModel>(builder, diagnostics);
            }

            return proxy;
        }
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) =>
            Equals(obj as ErrorProxy<TMacro, TModel>);
        /// <inheritdoc/>
        public Boolean Equals(ErrorProxy<TMacro, TModel>? other) =>
            other is not null && EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_proxied, other._proxied);
        /// <inheritdoc/>
        public override Int32 GetHashCode() =>
            -305811549 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_proxied);
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.Impl.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;
using System.Text;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Default implementation of <see cref="IExpandingMacroStringBuilder{TMacro}"/>.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support expansion for.</typeparam>
    internal sealed partial class Impl<TMacro> : IExpandingMacroStringBuilder<TMacro>
    {
        private Impl(
            Boolean isRoot,
            Queue<StringOrChar, TMacro> template,
            ExpansionObserver expansionObserver,
            Dictionary<TMacro, IMacroExpansion<TMacro>> expansionMap,
            StringBuilder builder)
        {
            _isRoot = isRoot;
            _template = template;
            _expansionObserver = expansionObserver;
            _expansionMap = expansionMap;
            _builder = builder;
        }

        private readonly Queue<StringOrChar, TMacro> _template;
        private readonly Dictionary<TMacro, IMacroExpansion<TMacro>> _expansionMap;
        private readonly ExpansionObserver _expansionObserver;
        private readonly StringBuilder _builder;
        private readonly Boolean _isRoot;

        /// <summary>
        /// Creates a new instance of the builder.
        /// </summary>
        /// <returns>A new builder instance.</returns>
        public static IExpandingMacroStringBuilder<TMacro> Create() =>
            new Impl<TMacro>(
                isRoot: true,
                template: new(),
                expansionObserver: ExpansionObserver.Create(),
                expansionMap: [],
                builder: new());
        private Impl<TMacro> Derive(Queue<StringOrChar, TMacro> template) =>
            new(
                isRoot: false,
                template: template,
                expansionObserver: _expansionObserver.Derive(),
                expansionMap: _expansionMap,
                builder: new());
        private Impl<TMacro> Clone()
        {
            return new(
                isRoot: true,
                template: _template.Clone(),
                expansionObserver: _expansionObserver.Clone(),
                expansionMap: _expansionMap,
                builder: _builder);
        }

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default)
        {
            var clone = Clone();
            clone.Expand(cancellationToken);
            clone.Reduce(cancellationToken);
            if(clone._template.ContainsMacros)
            {
                var macros = _template.GetMacros();
                throw new UnexpandedMacrosException<TMacro>(macros);
            } else
            {
                return clone._builder.ToString();
            }
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            _ = _template.EnqueueValue(value);
            Reduce(default);
            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            _ = _template.EnqueueValue(value);
            Reduce(default);
            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();

            _ = _template.EnqueueMacro(macro);
            if(_expansionMap.TryGetValue(macro, out var expansion))
            {
                Expand(expansion, cancellationToken);
                Reduce(cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if(!_isRoot)
            {
                //TODO
                throw new NotImplementedException("Providing macro expansions inside of macro expansions is not implemented yet.");
            }

            _expansionMap[provider.Macro] = provider;
            Expand(provider, cancellationToken);
            Reduce(cancellationToken);

            return this;
        }

        private void Expand(CancellationToken cancellationToken)
        {
            var expansions = _template.UnexpandedMacros()
                .Select(m => (HasExpansion: _expansionMap.TryGetValue(m, out var e), Expansion: e))
                .Where(t => t.HasExpansion);

            foreach(var (_, expansion) in expansions)
            {
                Expand(expansion, cancellationToken);
            }
        }
        private void Expand(IMacroExpansion<TMacro> expansion, CancellationToken cancellationToken)
        {
            _expansionObserver.NotifyExpansionStart(expansion.Macro);
            try
            {
                ExpansionObserver derivedObserver;
                do
                {
                    derivedObserver = _expansionObserver.Derive();
                    _ = _template.Expand(expansion.Macro, q => expansion.Expand(Derive(template: q), cancellationToken));
                } while(derivedObserver.Expanded);
            } finally
            {
                _expansionObserver.NotifyExpansionEnd(expansion.Macro);
            }
        }

        private void Reduce(CancellationToken cancellationToken)
        {
            if(!_isRoot)
            {
                return;
            }

            cancellationToken.ThrowIfCancellationRequested();

            var values = _template.DequeueValues();
            foreach(var value in values)
            {
                cancellationToken.ThrowIfCancellationRequested();

                _ = value.IsChar ?
                    _builder.Append(value.Char) :
                    _builder.Append(value.String);
            }
        }

        /// <inheritdoc/>
        public override String ToString() => $"({(_builder.Length > 0 ? _builder.ToString() : String.Empty)})-{_template}";
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.Impl.ExpansionObserver.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    partial class Impl<TMacro>
    {
        sealed class ExpansionObserver
        {
            private ExpansionObserver(HashSet<TMacro> recursionDetectionSet) => _recursionDetectionSet = recursionDetectionSet;

            public Boolean Expanded { get; private set; }
            private readonly HashSet<TMacro> _recursionDetectionSet;

            public static ExpansionObserver Create() => new([]);
            public ExpansionObserver Derive() => new(_recursionDetectionSet);
            public ExpansionObserver Clone() => new(new(_recursionDetectionSet))
            {
                Expanded = Expanded
            };

            public void NotifyExpansionStart(TMacro macro)
            {
                if(!_recursionDetectionSet.Add(macro))
                    throw new InfinitelyRecursingExpansionException<TMacro>(macro);
            }
            public void NotifyExpansionEnd(TMacro macro)
            {
                if(!_recursionDetectionSet.Remove(macro))
                    throw new ArgumentException($"Observer was not notified of {macro} expansion start.", nameof(macro));
                Expanded = true;
            }

            public override String ToString() => $"{(Expanded ? "Expanded" : "Not Expanded")} [{String.Join(",", _recursionDetectionSet)}]";
        }
    }
}
""");c.AddSource(
    "ExpandingMacroStringBuilder.Impl.StringOrChar.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    partial class Impl<TMacro>
    {
        readonly struct StringOrChar
        {
            public readonly Char Char;
            public readonly String? String;
            public readonly Boolean IsChar;

            public StringOrChar(Char @char)
            {
                Char = @char;
                String = null;
                IsChar = true;
            }
            public StringOrChar(String @string)
            {
                Char = default;
                String = @string;
                IsChar = false;
            }

            public static implicit operator StringOrChar(String @string) => new(@string);
            public static implicit operator StringOrChar(Char @char) => new(@char);

            public override String ToString() => IsChar ? Char.ToString() : String!;
        }
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.Queue.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;
using System.Text;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Represents a queue of values and macros. _macros may be replaced at a later time.
    /// </summary>
    /// <typeparam name="TValue">The type of value to enqueue.</typeparam>
    /// <typeparam name="TMacro">The type of macro to enqueue.</typeparam>
    internal sealed partial class Queue<TValue, TMacro>
    {
        private Queue(Dictionary<TMacro, Stack<Queue<TValue, TMacro>.Node<TMacro>>> macros) => _macros = macros;
        public Queue() : this([]) { }

        private readonly Dictionary<TMacro, Stack<Node<TMacro>>> _macros;
        private Node? _first;
        private Node? _last;

        /// <summary>
        /// Gets a value indicating whether the queue contains any macros.
        /// </summary>
        public Boolean ContainsMacros => _macros.Any(static kvp => kvp.Value.Count > 0);
        public IReadOnlyList<TMacro> GetMacros() => _macros.SelectMany(static kvp => kvp.Value).Select(static n => n.Value).ToList();

        /// <summary>
        /// Gets an enumeration of distinct macros that have yet to be expanded.
        /// </summary>
        /// <returns>The distinct macros that have yet to be expanded.</returns>
        public IEnumerable<TMacro> UnexpandedMacros() => _macros.Where(s => s.Value.Count > 0).Select(kvp => kvp.Key);
        /// <summary>
        /// Adds a value to the end of the queue.
        /// </summary>
        /// <param name="value">The value to enqueue.</param>
        public Queue<TValue, TMacro> EnqueueValue(TValue value)
        {
            var node = Node<TValue>.Rent(value);
            Enqueue(node);
            return this;
        }
        /// <summary>
        /// Adds a macro to the end of the queue.
        /// </summary>
        /// <param name="macro">The macro to enqueue.</param>
        public Queue<TValue, TMacro> EnqueueMacro(TMacro macro)
        {
            var node = Node<TMacro>.Rent(macro);
            GetMacroNodes(macro).Push(node);
            Enqueue(node);
            return this;
        }
        /// <summary>
        /// Dequeues all sequential values from the end of the queue.
        /// </summary>
        /// <returns>The sequential values at the end of the queue.</returns>
        public IEnumerable<TValue> DequeueValues()
        {
            while(_first is Node<TValue> valueNode)
            {
                if(_last == _first)
                {
                    _last = valueNode.Next;
                }

                _first = valueNode.Next;
                var value = valueNode.Value;
                RemoveNode(valueNode);

                yield return value;
            }
        }
        /// <summary>
        /// Replaces all occurences of a macro with the replacement queue provided.
        /// </summary>
        /// <param name="macro">The macro to replace.</param>
        /// <param name="configureExpansionQueue">The action using which to configure the queue of items to replace occurences of the macro with.</param>
        public Queue<TValue, TMacro> Expand(TMacro macro, Action<Queue<TValue, TMacro>> configureExpansionQueue)
        {
            var nodes = GetMacroNodes(macro);
            if(nodes.Count == 0)
            {
                return this;
            }

            var replacementQueue = new Queue<TValue, TMacro>();
            configureExpansionQueue.Invoke(replacementQueue);

            if(replacementQueue._first == null)
            {
                RemoveMacros(nodes);
            } else
            {
                ReplaceMacros(replacementQueue, nodes);
            }

            return this;
        }

        private void Enqueue(Node? node)
        {
            if(_first == null)
            {
                _first = node;
            } else if(_last != null)
            {
                _last.Next = node;
                if(node != null)
                {
                    node.Previous = _last;
                }
            }

            _last = node;
        }
        private Stack<Node<TMacro>> GetMacroNodes(TMacro macro)
        {
            if(!_macros.TryGetValue(macro, out var nodes))
            {
                nodes = [];
                _macros.Add(macro, nodes);
            }

            return nodes;
        }
        private void ReplaceMacros(Queue<TValue, TMacro> replacementQueue, Stack<Node<TMacro>> nodes)
        {
            while(nodes.Count > 0)
            {
                var node = nodes.Pop();
                node.Replace(replacementQueue._first, replacementQueue._last);

                if(node == _first)
                {
                    _first = replacementQueue._first;
                }

                if(node == _last)
                {
                    _last = replacementQueue._last;
                }

                foreach(var kvp in replacementQueue._macros)
                {
                    while(kvp.Value.Count > 0)
                    {
                        GetMacroNodes(kvp.Key).Push(kvp.Value.Pop());
                    }
                }

                Node<TMacro>.Return(node);

                if(nodes.Count > 0)
                {
                    replacementQueue = replacementQueue.Clone();
                }
            }
        }
        private void RemoveMacros(Stack<Node<TMacro>> nodes)
        {
            while(nodes.Count > 0)
                RemoveNode(nodes.Pop());
        }
        private void RemoveNode<T>(Node<T> node)
        {
            RemoveFirstOrLast(node);
            node.RemoveSelf();
            Node<T>.Return(node);
        }
        private void RemoveFirstOrLast(Node node)
        {
            if(node == _first)
            {
                _first = null;
            }

            if(node == _last)
            {
                _last = null;
            }
        }
        private IEnumerable<Node> GetNodes()
        {
            var node = _first;
            while(node != null)
            {
                yield return node;

                node = node.Next;
            }
        }
        /// <inheritdoc/>
        public override String ToString() => GetNodes().Aggregate(new StringBuilder(), static (b, s) => b.Append(s)).ToString();
        internal Queue<TValue, TMacro> Clone()
        {
            var result = new Queue<TValue, TMacro>(new(_macros));
            var firstClone = _first?.Clone();
            result.Enqueue(firstClone);

            return result;
        }
    }
}

""");c.AddSource(
    "ExpandingMacroStringBuilder.Queue.Node.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

partial class ExpandingMacroStringBuilder
{
    sealed partial class Queue<TValue, TMacro>
    {
        sealed class Node<T> : Node
        {
            private Node(T value) => _value = value;

            public T Value
            {
                get
                {
                    ValidateRented();
                    return _value!;
                }
                private set
                {
                    ValidateRented();
                    _value = value;
                }
            }

            private static readonly ConcurrentBag<Node<T>> _pool = [];
            private T? _value;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static Node<T> Rent(T value)
            {
                if(_pool.TryTake(out var result))
                {
                    result.SetRented();
                    result.Value = value;
                } else
                {
                    result = new Node<T>(value);
                    result.SetRented();
                }

                return result;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Return(Node<T> node)
            {
                node._value = default;
                node.Next = default;
                node.Previous = default;
                node.SetReturned();
                _pool.Add(node);
            }

            public override String ToString() => base.ToString().Replace("[ ]", $"[{(IsRented ? $"\"{Value}\"" : "_")}]");
            protected override Node CreateClone()
            {
                var result = Rent(Value);
                result.Previous = Previous?.Clone();
                result.Next = Next?.Clone();

                return result;
            }
        }
        abstract class Node
        {
            private Node? _previous;
            private Node? _next;

            public Node? Next
            {
                get
                {
                    ValidateRented();
                    return _next;
                }

                set
                {
                    ValidateRented();
                    _next = value;
                }
            }
            public Node? Previous
            {
                get
                {
                    ValidateRented();
                    return _previous;
                }

                set
                {
                    ValidateRented();
                    _previous = value;
                }
            }

            private Boolean _cloning;

            private const Int32 _rentedState = 1;
            private const Int32 _returnedState = 0;
            private Int32 _isRented = _returnedState;

            protected Boolean IsRented => _isRented == _rentedState;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void ValidateRented()
            {
                if(_isRented == _returnedState)
                {
                    throw new InvalidOperationException("Unable to access returned node.");
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void SetRented()
            {
                if(Interlocked.Exchange(ref _isRented, _rentedState) == _rentedState)
                {
                    throw new InvalidOperationException("Unable to rent node multiple times.");
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void SetReturned()
            {
                if(Interlocked.Exchange(ref _isRented, _returnedState) == _returnedState)
                {
                    throw new InvalidOperationException("Unable to return node multiple times.");
                }
            }

            public void RemoveSelf()
            {
                if(Previous != null)
                    Previous.Next = Next;

                if(Next != null)
                    Next.Previous = Previous;
            }
            public void Replace(Node? first, Node? last)
            {
                if(Previous != null)
                    Previous.Next = first;
                if(first != null)
                    first.Previous = Previous;

                if(Next != null)
                    Next.Previous = last;
                if(last != null)
                    last.Next = Next;

                Previous = null;
                Next = null;
            }

            public override String ToString() => $"{(_previous != null ? "<" : String.Empty)}[ ]{(_next != null ? ">" : String.Empty)}";
            protected abstract Node CreateClone();
            internal Node Clone()
            {
                if(_cloning)
                {
                    return this;
                }

                _cloning = true;
                var result = CreateClone();
                _cloning = false;

                return result;
            }
        }
    }
}

""");c.AddSource(
    "GeneratorContext.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

/// <summary>
/// Contains factory methods for generator contexts.
/// </summary>
static partial class GeneratorContext
{
    /// <summary>
    /// Creates a new generator context.
    /// </summary>
    /// <param name="model">The model based on which to generate source code and diagnostics.</param>
    /// <param name="configureSourceTextBuilder">
    /// The optional configuration to apply to the underlying source 
    /// text builder after its instantiation.
    /// </param>
    /// <param name="configureDiagnosticsAccumulator">
    /// The optional configuration to apply to the underlying diagnostics
    /// accumulator after its instantiation.
    /// </param>
    /// <returns>The new generator context.</returns>
    public static IGeneratorContext<TMacro, TModel> Create<TMacro, TModel>(
        TModel model,
        Func<IExpandingMacroStringBuilder<TMacro>, IExpandingMacroStringBuilder<TMacro>>? configureSourceTextBuilder = null,
        Func<IDiagnosticsAccumulator<TModel>, IDiagnosticsAccumulator<TModel>>? configureDiagnosticsAccumulator = null)
    {
        var diagnosticsAccumulator = DiagnosticsAccumulator.Create(model);
        if(configureDiagnosticsAccumulator != null)
        {
            diagnosticsAccumulator = configureDiagnosticsAccumulator.Invoke(diagnosticsAccumulator);
        }

        var builder = ExpandingMacroStringBuilder.Create<TMacro>()
            .InterceptErrors(diagnosticsAccumulator);
        if(configureSourceTextBuilder != null)
        {
            builder = configureSourceTextBuilder.Invoke(builder);
        }

        var interceptedBuilder = new ErrorProxy<TMacro, TModel>(
            builder,
        diagnosticsAccumulator);

        var result = new Impl<TMacro, TModel>(
            interceptedBuilder,
            diagnosticsAccumulator,
            model);

        return result;
    }
}

""");c.AddSource(
    "GeneratorContext.ErrorProxy.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;
using System.Collections.Generic;

partial class GeneratorContext
{
    /// <summary>
    /// Proxies operations on an expanding macro string builder against error diagnostics. 
    /// Operations will only be passed through if no errors have been diagnosed 
    /// to the diagnostics accumulator provided.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model whose diagnostics to query.</typeparam>
    /// <param name="proxied">The expanding macro string builder to proxy.</param>
    /// <param name="diagnostics">The diagnostics accumulator to query for errors when intercepting operations.</param>
    internal sealed class ErrorProxy<TMacro, TModel>(
        IExpandingMacroStringBuilder<TMacro> proxied,
        IDiagnosticsAccumulator<TModel> diagnostics) :
        IExpandingMacroStringBuilder<TMacro>,
        IEquatable<ErrorProxy<TMacro, TModel>?>
    {
        private readonly IExpandingMacroStringBuilder<TMacro> _proxied = proxied;
        private readonly IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default) => _proxied.Build(cancellationToken);
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.AppendMacro(macro, cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Receive(provider, cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) =>
            Equals(obj as ErrorProxy<TMacro, TModel>);
        /// <inheritdoc/>
        public Boolean Equals(ErrorProxy<TMacro, TModel>? other) =>
            other is not null && EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_proxied, other._proxied);
        /// <inheritdoc/>
        public override Int32 GetHashCode() =>
            -305811549 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_proxied);
    }
}

""");c.AddSource(
    "GeneratorContext.Impl.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;
using System.Collections.Generic;

partial class GeneratorContext
{
    internal sealed class Impl<TMacro, TModel>(
    IExpandingMacroStringBuilder<TMacro> builder,
    IDiagnosticsAccumulator<TModel> diagnostics,
    TModel model) : IEquatable<Impl<TMacro, TModel>?>, IGeneratorContext<TMacro, TModel>
    {
        /// <summary>
        /// The underlying expanding macro string builder.
        /// </summary>
        private IExpandingMacroStringBuilder<TMacro> _sourceText = builder;
        /// <summary>
        /// The underlying diagnostics accumulator.
        /// </summary>
        private IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;
        /// <inheritdoc/>
        public TModel Model { get; } = model;

        public IGeneratorContext<TMacro, TModel> ApplyToSource(
            Func<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken, IExpandingMacroStringBuilder<TMacro>> build,
            CancellationToken cancellationToken)
        {
            _sourceText = build.Invoke(_sourceText, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToSource(
            Action<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken> build,
            CancellationToken cancellationToken)
        {
            build.Invoke(_sourceText, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(
            Func<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken, IDiagnosticsAccumulator<TModel>> diagnose,
            CancellationToken cancellationToken)
        {
            _diagnostics = diagnose.Invoke(_diagnostics, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(
            Action<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken> diagnose,
            CancellationToken cancellationToken)
        {
            diagnose.Invoke(_diagnostics, Model, cancellationToken);
            return this;
        }

        /// <inheritdoc/>
        public IGeneratorContext<TMacro, TModel> Receive<TProvider>(TProvider provider)
            where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>
        {
            _ = _diagnostics.Receive(provider);
            _ = _sourceText.Receive(provider);
            return this;
        }
        /// <inheritdoc/>
        public IGeneratorContext<TMacro, TModel> Receive<TProvider>()
            where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>, new() =>
            Receive(new TProvider());

        /// <inheritdoc/>
        public String BuildSource(CancellationToken cancellationToken) => _sourceText.Build(cancellationToken);

        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) => Equals(obj as Impl<TMacro, TModel>);
        /// <inheritdoc/>
        public Boolean Equals(Impl<TMacro, TModel>? other) => other is not null && EqualityComparer<TModel>.Default.Equals(Model, other.Model);
        /// <inheritdoc/>
        public override Int32 GetHashCode() => -623947254 + EqualityComparer<TModel>.Default.GetHashCode(Model);
    }
}

""");c.AddSource(
    "IDiagnosticProvider.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

/// <summary>
/// Reports model diagnostics to an accumulator.
/// </summary>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IDiagnosticProvider<TModel>
{
    /// <summary>
    /// Diagnoses a model.
    /// </summary>
    /// <param name="model">The model to diagnose.</param>
    /// <param name="accumulator">The accumulator to report diagnostics to.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    void Diagnose(TModel model, IDiagnosticsAccumulator<TModel> accumulator, CancellationToken cancellationToken = default);
}

""");c.AddSource(
    "IDiagnosticsAccumulator.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

using System.Threading;

/// <summary>
/// Incrementally accumulates model diagnostics.
/// </summary>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IDiagnosticsAccumulator<TModel>
{
    /// <summary>
    /// Gets a value indicating whether the accumulator currently contains errors.
    /// </summary>
    Boolean ContainsErrors { get; }
    /// <summary>
    /// Adds a diagnostic to the accumulator.
    /// </summary>
    /// <param name="diagnostic">The diagnostic to add.</param>
    /// <returns>A reference to the accumulator, for chaining of further method calls.</returns>
    IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic);
    /// <summary>
    /// Reports the accumulated diagnostics to a report handler.
    /// For instance, the handler could be the <see cref="SyntaxNodeAnalysisContext.ReportDiagnostic(Diagnostic)"/> method.
    /// </summary>
    /// <param name="report">The context action to invoke in order to report diagnostics.</param>
    void ReportDiagnostics(Action<Diagnostic> report);
    /// <summary>
    /// Receives a diagnostics provider for generating diagnostics on the model.
    /// </summary>
    /// <param name="provider">The provider to generate diagnostics with.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference tothe accumulator, for chaining of further method calls.</returns>
    IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default);
}
""");c.AddSource(
    "IExpandingMacroStringBuilder.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

/// <summary>
/// Represents a builder for incrementally constructing strings based on values and macros.
/// Macros must be expanded into values and/or further macros. 
/// The builder may only build the final result once there are no more macros to expand.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
interface IExpandingMacroStringBuilder<TMacro>
{
    /// <summary>
    /// Builds the result string.
    /// </summary>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>The result string.</returns>
    String Build(CancellationToken cancellationToken = default);
    /// <summary>
    /// Appends a string value to the builder.
    /// </summary>
    /// <param name="value">The string value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Append(String value);
    /// <summary>
    /// Appends a string value to the builder.
    /// </summary>
    /// <param name="value">The character value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Append(Char value);
    /// <summary>
    /// Appends a macro to the builder.
    /// </summary>
    /// <param name="macro">The macro to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default);
    /// <summary>
    /// Registers a expansion provider to the builder and potentially executes macro expansions.
    /// </summary>
    /// <param name="provider">The provider to register.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default);
}

""");c.AddSource(
    "IGeneratorContext.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

/// <summary>
/// Represents the generator context for incremental generators. 
/// Appending or substituting values to the underlying source text 
/// builder are intercepted and discarded if the underlying
/// diagnostics accumulator is currently reporting errors.
/// This means that the expanding macro string builder provided by context 
/// instances will essentially short circuit upon errors having been 
/// reported by the diagnostics accumulator.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IGeneratorContext<TMacro, TModel>
{
    /// <summary>
    /// Gets the model to incrementally build up.
    /// </summary>
    TModel Model { get; }

    /// <summary>
    /// Applies a modification to the diagnostics accumulator underlying the context.
    /// </summary>
    /// <param name="diagnose">The modification to apply to the underlying diagnostics accumulator.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(Action<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken> diagnose, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a transformation to the diagnostics accumulator underlying the context.
    /// </summary>
    /// <param name="diagnose">The transformation to apply to the underlying diagnostics accumulator.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(Func<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken, IDiagnosticsAccumulator<TModel>> diagnose, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a modification to the string builder underlying the context.
    /// </summary>
    /// <param name="build">The modification to apply to the underlying string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToSource(Action<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken> build, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a transformation to the string builder underlying the context.
    /// </summary>
    /// <param name="build">The transformation to apply to the underlying string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToSource(Func<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken, IExpandingMacroStringBuilder<TMacro>> build, CancellationToken cancellationToken);

    /// <summary>
    /// Receives a new expansion and diagnostics provider of the type provided, 
    /// to be received by both the underlying diagnostics accumulator, as well 
    /// as the underlying source text builder.
    /// </summary>
    /// <typeparam name="TProvider">The type of provider to receive.</typeparam>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> Receive<TProvider>() where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>, new();
    /// <summary>
    /// Receives a expansion and diagnostics provider, to be received by both 
    /// the underlying diagnostics accumulator, as well as the underlying 
    /// source text builder.
    /// </summary>
    /// <typeparam name="TProvider">The type of provider to receive.</typeparam>
    /// <param name="provider">The provider to receive.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> Receive<TProvider>(TProvider provider) where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>;

    /// <summary>
    /// Builds the source text.
    /// </summary>
    /// <param name="cancellationToken">The cancellation token used to signal source text generation to cancel.</param>
    /// <returns>The built source code.</returns>
    String BuildSource(CancellationToken cancellationToken);
}

""");c.AddSource(
    "IMacroExpansion.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

/// <summary>
/// Expands macro instances into values and/or further macros.
/// </summary>
/// <typeparam name="TMacro">The type of macro to expand.</typeparam>
interface IMacroExpansion<TMacro>
{
    /// <summary>
    /// Gets the macro instance to expand.
    /// </summary>
    TMacro Macro { get; }
    /// <summary>
    /// Expands the macro into an expanding macro string builder.
    /// </summary>
    /// <param name="builder">The builder to expand the macro into.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    void Expand(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken);
}

""");c.AddSource(
    "InfinitelyRecursingExpansionException.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

/// <summary>
/// Thrown if an infinite macro expansion is detected.
/// </summary>
/// <typeparam name="TMacro">The type of macro to be expanded into a sequence containing itself.</typeparam>
/// <param name="macro">The macro to be expanded into a sequence containing itself.</param>
sealed class InfinitelyRecursingExpansionException<TMacro>(TMacro macro)
    : Exception($"Detected infinitely recursing macro expansion while expanding '{macro}'. Make sure that macro expansions do not expand into themselves.")
{
    /// <summary>
    /// Gets the macro to be expanded into a sequence containing itself.
    /// </summary>
    public TMacro Macro { get; } = macro;
}

""");c.AddSource(
    "MacroExpansion.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

/// <summary>
/// Provides a base class for types implementing <see cref="IMacroExpansion{TMacro}"/>.
/// </summary>
/// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
/// <param name="macro">The macro to expand using this provider.</param>
abstract class MacroExpansion<TMacro>(TMacro macro) : IMacroExpansion<TMacro>
{
    /// <inheritdoc/>
    public TMacro Macro { get; } = macro;
    /// <inheritdoc/>
    public abstract void Expand(
        IExpandingMacroStringBuilder<TMacro> builder,
        CancellationToken cancellationToken);
}
/// <summary>
/// Provides factory and extension methods for macro expansion providers.
/// </summary>
static partial class MacroExpansion
{
    /// <summary>
    /// Creates a new empty macro expansion for the macro provided.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide an empty expansion for.</typeparam>
    /// <param name="macro">The macro to expand using the provider created.</param>
    /// <returns>A new empty macro expansion.</returns>
    public static IMacroExpansion<TMacro> CreateEmpty<TMacro>(TMacro macro) => new Empty<TMacro>(macro);
    /// <summary>
    /// Creates a new macro expansion provider.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
    /// <param name="macro">The macro to expand using the provider created.</param>
    /// <param name="strategy">The strategy using which to supply an expansion to an expanding macro string builder.</param>
    /// <returns>A new expansion.</returns>
    public static IMacroExpansion<TMacro> Create<TMacro>(
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy) =>
        new Strategy<TMacro>(macro, strategy);
}
""");c.AddSource(
    "MacroExpansion.Empty.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;
static partial class MacroExpansion
{
    internal sealed class Empty<TMacro>(TMacro macro) : MacroExpansion<TMacro>(macro)
    {
        public override void Expand(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken) { }
    }
}
""");c.AddSource(
    "MacroExpansion.Strategy.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

partial class MacroExpansion
{
    /// <summary>
    /// Imlements a strategy-based expansion provider.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
    /// <param name="macro">The macro to replace.</param>
    /// <param name="strategy">The strategy to use when replacing the macro.</param>
    internal sealed class Strategy<TMacro>(
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy) :
        MacroExpansion<TMacro>(macro)
    {
        private readonly Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> _strategy = strategy;
        /// <inheritdoc/>
        public override void Expand(
            IExpandingMacroStringBuilder<TMacro> builder,
            CancellationToken cancellationToken) =>
            _strategy.Invoke(builder, cancellationToken);
    }
}
""");c.AddSource(
    "SymbolExtensions.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using Microsoft.CodeAnalysis;

using System;

static class SymbolExtensions
{
    /// <summary>
    /// Gets the legible, fully qualified name of a symbol; suitable for use in hint names.
    /// </summary>
    /// <param name="symbol">The symbol whose hint name to get.</param>
    /// <returns>The symbols hint name.</returns>
    public static String ToHintName(this ISymbol symbol)=>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
                    .WithMiscellaneousOptions(
                    /*
                        get rid of special types

                                10110
                        NAND 00100
                            => 10010

                                10110
                            &! 00100
                            => 10010

                                00100
                            ^ 11111
                            => 11011

                                10110
                            & 11011
                            => 10010
                    */
                    SymbolDisplayFormat.FullyQualifiedFormat.MiscellaneousOptions &
                    (SymbolDisplayMiscellaneousOptions.UseSpecialTypes ^ (SymbolDisplayMiscellaneousOptions)Int32.MaxValue))
                    .WithGenericsOptions(SymbolDisplayGenericsOptions.IncludeTypeParameters))
                    .Replace("<", "_of_")
                    .Replace('>', '_')
                    .Replace(",", "_and_")
                    .Replace(" ", String.Empty)
                    .Replace('.', '_')
                    .Replace("::", "_")
                    .TrimEnd('_');
}

""");c.AddSource(
    "UnexpandedMacrosException.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
#pragma warning disable
namespace RhoMicro.CodeAnalysis.UtilityGenerators.Library;

using System;

/// <summary>
/// Thrown if <see cref="IExpandingMacroStringBuilder{TMacro}.Build(CancellationToken)"/> has been called but there are unexpanded macros present in the builder.
/// </summary>
/// <typeparam name="TMacro">The type of unexpanded macro.</typeparam>
/// <param name="macros">The list of unexpanded macros.</param>
sealed class UnexpandedMacrosException<TMacro>(IReadOnlyList<TMacro> macros) 
    : Exception($"Unable to build string; there is at least one unexpanded macro present in the builder. Make sure to provide expansions for all macros in use. Unexpanded macros: {String.Join(", ", macros)}")
{
    /// <summary>
    /// Gets the unexpanded macros.
    /// </summary>
    public IReadOnlyList<TMacro> Macros { get; } = macros;
}
""");
        });
    }
}