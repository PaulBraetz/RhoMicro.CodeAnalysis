// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.Library.Generator on 03/11/2024 08:51:55 +00:00
// </auto-generated>
#pragma warning disable

namespace RhoMicro.CodeAnalysis.UtilityGenerators;

using Microsoft.CodeAnalysis;
using System;
    
/// <summary>
/// Generates types from the <c>RhoMicro.CodeAnalysis.Library</c> library into the target project.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed partial class LibraryGenerator : IIncrementalGenerator
{
    static partial void InitializeStatic(IncrementalGeneratorInitializationContext context);
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        InitializeStatic(context);
        context.RegisterPostInitializationOutput(static c =>
        {
            String path = String.Empty;

            
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\BoundedInterval.cs";
#endif
c.AddSource(
    "BoundedInterval85698271_5645_4d4e_bf8e_c41bb037e946.g.cs", 
$$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{{DateTimeOffset.Now}}}
// </auto-generated>
{{{path}}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;

/// <summary>
/// Represents a left- and right-bounded interval.
/// </summary>
/// <typeparam name="T">The type of values represented by the interval.</typeparam>
/// <remarks>
/// Initializes a new instance.
/// </remarks>
/// <param name="LeftBound">The intervals left (usually lower) bound.</param>
/// <param name="RightBound">The intervals right (usually upper) bound.</param>
/// <param name="LeftClosed">Indicates whether or not <see cref="LeftBound"/> is to be included in the interval. The default is <see langword="true"/>.</param>
/// <param name="RightClosed">Indicates whether or not <see cref="RightBound"/> is to be included in the interval. The default is <see langword="false"/>.</param>
[DebuggerDisplay("{ToString()}")]
readonly record struct BoundedInterval<T>(T LeftBound, T RightBound, Boolean LeftClosed = true, Boolean RightClosed = false) : IEquatable<BoundedInterval<T>>
{
    /// <summary>
    /// The empty interval.
    /// </summary>
    public static readonly BoundedInterval<T> Empty = new();
    /// <summary>
    /// Returns whether or not a bounded interval is empty, using <see cref="EqualityComparer{T}.Default"/>.
    /// </summary>
    /// <remarks>
    /// A given bounded interval is defined as empty when its left and right bound are equal and it is not left- and right-closed.
    /// </remarks>
    /// <returns><see langword="true"/> if the interval is empty; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsEmpty() => IsEmpty(EqualityComparer<T>.Default);
    /// <summary>
    /// Returns whether or not a bounded interval is empty.
    /// </summary>
    /// <remarks>
    /// A given bounded interval is defined as empty when its left and right bound are equal and it is not left- and right-closed.
    /// </remarks>
    /// <param name="comparer">The comparer to use when comparing the left and right bound of the interval.</param>
    /// <returns><see langword="true"/> if the interval is empty; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsEmpty(IEqualityComparer<T> comparer)
    {
        var result = comparer.Equals(LeftBound, RightBound) && !(LeftClosed && RightClosed);

        return result;
    }
    /// <summary>
    /// Returns whether or not a bounded interval is degenerate, that is, walking it would yield exactly one element, using <see cref="EqualityComparer{T}.Default"/>.
    /// </summary>
    /// <remarks>
    /// A given bounded interval is defined as degenerate when its left and right bound are equal and it is left- and right-closed.
    /// </remarks>
    /// <returns><see langword="true"/> if the interval is degenerate; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsDegenerate()
    {
        var result = IsDegenerate(EqualityComparer<T>.Default);

        return result;
    }
    /// <summary>
    /// Returns whether or not a bounded interval is degenerate, that is, walking it would yield exactly one element.
    /// </summary>
    /// <remarks>
    /// A given bounded interval is defined as degenerate when its left and right bound are equal and it is left- and right-closed.
    /// </remarks>
    /// <param name="comparer">The comparer to use when comparing the left and right bound of the interval.</param>
    /// <returns><see langword="true"/> if the interval is degenerate; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsDegenerate(IEqualityComparer<T> comparer)
    {
        var result = comparer.Equals(LeftBound, RightBound) && LeftClosed && RightClosed;

        return result;
    }
    /// <summary>
    /// Walks a bounded interval using a walker function until the intervals right bound has been reached.
    /// </summary>
    /// <param name="walker">The walker, which will be passed the last element and calculate from it the next element.</param>
    /// <param name="comparer">The comparer to be used for determining whether the intervals right bound has been reached.</param>
    /// <returns>An enumerable, enumerating the values yielded by <paramref name="walker"/> while walking the interval.</returns>
    public IEnumerable<T> Walk(Func<T, T> walker, IEqualityComparer<T> comparer)
    {
        if(IsDegenerate(comparer))
        {
            yield return LeftBound;
        } else if(!IsEmpty(comparer))
        {
            var result = LeftBound;
            if(LeftClosed)
                yield return result;

            while(!comparer.Equals(result, RightBound))
            {
                result = walker.Invoke(result);

                yield return result;
            }

            if(RightClosed)
                yield return result;
        }
    }
    /// <summary>
    /// Walks a bounded interval using a walker function until the intervals right bound has been reached, using <see cref="EqualityComparer{T}.Default"/>.
    /// </summary>
    /// <param name="walker">The walker, which will be passed the last element and calculate from it the next element.</param>
    /// <returns>An enumerable, enumerating the values yielded by <paramref name="walker"/> while walking the interval.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IEnumerable<T> Walk(Func<T, T> walker)
    {
        var result = Walk(walker, EqualityComparer<T>.Default);

        return result;
    }
    /// <summary>
    /// Returns whether or not a given left- and right-bounded interval contains a value.
    /// </summary>
    /// <param name="value">The value to check for.</param>
    /// <param name="comparer">The comparer to use for determining the order of values represented by the interval.</param>
    /// <returns><see langword="true"/> if the interval contains <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean Contains(T value, IComparer<T> comparer)
    {
        var result =
            comparer.Compare(value, RightBound) < (RightClosed ? 1 : 0) &&
            comparer.Compare(value, LeftBound) > (LeftClosed ? -1 : 0);

        return result;
    }
    /// <summary>
    /// Returns whether or not a given left- and right-bounded interval contains a value.
    /// </summary>
    /// <param name="value">The value to check for.</param>
    /// <returns><see langword="true"/> if the interval contains <paramref name="value"/>; otherwise, <see langword="false"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean Contains(T value)
    {
        var result = Contains(value, Comparer<T>.Default);

        return result;
    }
    /// <inheritdoc/>
    public override String ToString()
    {
        var result = $"{bracket(LeftClosed)}{LeftBound}, {RightBound}{bracket(!RightClosed)}";

        return result;

        static Char bracket(Boolean inclusive) => inclusive ? '[' : ']';
    }
    /// <inheritdoc/>
    public Boolean Equals(BoundedInterval<T> other) =>
        IsEmpty() && other.IsEmpty() ||
        IsDegenerate() && other.IsDegenerate() && EqualityComparer<T>.Default.Equals(LeftBound, other.LeftBound) ||
        LeftClosed == other.LeftClosed &&
        RightClosed == other.RightClosed &&
        EqualityComparer<T>.Default.Equals(LeftBound, other.LeftBound) &&
        EqualityComparer<T>.Default.Equals(RightBound, other.RightBound);
    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override Int32 GetHashCode() => (LeftBound, LeftClosed, RightBound, RightClosed).GetHashCode();
}
/// <summary>
/// Contains helper methods for bounded intervals.
/// </summary>
static class BoundedInterval
{
    /// <summary>
    /// Creates a left- and right-bounded interval.
    /// </summary>
    /// <param name="leftBound">The intervals left (usually lower) bound.</param>
    /// <param name="rightBound">The intervals right (usually upper) bound.</param>
    /// <param name="leftClosed">Indicates whether or not <paramref name="leftBound"/> is to be included in the interval. The default is <see langword="true"/>.</param>
    /// <param name="rightClosed">Indicates whether or not <paramref name="rightBound"/> is to be included in the interval. The default is <see langword="false"/>.</param>
    /// <returns>A new left- and right-bounded interval.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static BoundedInterval<T> Create<T>(
        T leftBound,
        T rightBound,
        Boolean leftClosed = true,
        Boolean rightClosed = false)
    {
        var interval = new BoundedInterval<T>(leftBound, rightBound, leftClosed, rightClosed);

        return interval;
    }

    /// <summary>
    /// Creates a single-element interval.
    /// </summary>
    /// <param name="element">The intervals single element.</param>
    /// <returns>The degenerate (left- and right-closed) interval, whose left and right bound are <paramref name="element"/>.</returns>
    public static BoundedInterval<T> CreateDegenerate<T>(T element)
    {
        var result = new BoundedInterval<T>(element, element, true, true);

        return result;
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\CollectionEqualityComparer.cs";
#endif
c.AddSource(
    "CollectionEqualityComparer2b3e6e04_0e6c_408b_b5f6_12702923bb7d.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

sealed class CollectionEqualityComparer<T>(IEqualityComparer<T> elementComparer) : IEqualityComparer<IEnumerable<T>>
{
    public static CollectionEqualityComparer<T> Default { get; } = new(EqualityComparer<T>.Default);
    private readonly IEqualityComparer<T> _elementComparer = elementComparer;

    public Boolean Equals(IEnumerable<T> x, IEnumerable<T> y) => x.SequenceEqual(y, _elementComparer);
    public Int32 GetHashCode(IEnumerable<T> obj)
    {
        var hashCode = 997021164;
        foreach(var element in obj)
        {
            hashCode = hashCode * -1521134295 + _elementComparer.GetHashCode(element);
        }

        return hashCode;
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\CSharpBuilderFormattingOptions.cs";
#endif
c.AddSource(
    "CSharpBuilderFormattingOptionsc8636566_1a84_4043_ae93_5b34b4abafea.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis.CSharp;

using System;
using System.Collections.Generic;

/// <summary>
/// Represents the settings used for formatting the c# output produced by an instance of <see cref="IExpandingMacroStringBuilder{TMacro}"/>.
/// </summary>
/// <param name="parseOptions">
/// The options to use when parsing the generated source text.
/// </param>
/// <param name="indentation">
/// An optional sequence of whitespace characters that defines a single level of
/// indentation.
/// </param>
/// <param name="endOfLine">
/// An optional sequence of whitespace characters used for end of line.
/// </param>
/// <param name="elasticTrivia">
/// If true the replaced trivia is elastic trivia.
/// </param>
readonly struct CSharpBuilderFormattingOptions(
    CSharpParseOptions parseOptions,
    String indentation = "\t",
    String endOfLine = "\r\n",
    Boolean elasticTrivia = false) : IEquatable<CSharpBuilderFormattingOptions>
{
    /// <summary>
    /// The default options.
    /// </summary>
    public static readonly CSharpBuilderFormattingOptions Default = new(CSharpParseOptions.Default);

    /// <summary>
    /// The options to use when parsing the generated source text.
    /// </summary>
    public CSharpParseOptions ParseOptions { get; } = parseOptions;
    /// <summary>
    /// An optional sequence of whitespace characters that defines a single level of
    /// indentation.
    /// </summary>
    public String Indentation { get; } = indentation;
    /// <summary>
    /// An optional sequence of whitespace characters used for end of line.
    /// </summary>
    public String EndOfLine { get; } = endOfLine;
    /// <summary>
    /// If true the replaced trivia is elastic trivia.
    /// </summary>
    public Boolean ElasticTrivia { get; } = elasticTrivia;

    /// <inheritdoc/>
    public override Boolean Equals(Object? obj) => obj is CSharpBuilderFormattingOptions options && Equals(options);
    /// <inheritdoc/>
    public Boolean Equals(CSharpBuilderFormattingOptions other) => EqualityComparer<CSharpParseOptions>.Default.Equals(ParseOptions, other.ParseOptions)
        && Indentation == other.Indentation
        && EndOfLine == other.EndOfLine
        && ElasticTrivia == other.ElasticTrivia;
    /// <inheritdoc/>
    public override Int32 GetHashCode()
    {
        var hashCode = -551825062;
        hashCode = hashCode * -1521134295 + EqualityComparer<CSharpParseOptions>.Default.GetHashCode(ParseOptions);
        hashCode = hashCode * -1521134295 + EqualityComparer<String>.Default.GetHashCode(Indentation);
        hashCode = hashCode * -1521134295 + EqualityComparer<String>.Default.GetHashCode(EndOfLine);
        hashCode = hashCode * -1521134295 + ElasticTrivia.GetHashCode();
        return hashCode;
    }
    public static Boolean operator ==(CSharpBuilderFormattingOptions left, CSharpBuilderFormattingOptions right) => left.Equals(right);
    public static Boolean operator !=(CSharpBuilderFormattingOptions left, CSharpBuilderFormattingOptions right) => !(left == right);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticProvider.cs";
#endif
c.AddSource(
    "DiagnosticProviderd7970a50_09ca_4802_934f_2464f2e1e509.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

/// <summary>
/// Contains factory and extension methods for diagnostic providers.
/// </summary>
static partial class DiagnosticProvider
{
    /// <summary>
    /// Creates a new diagnostic provider.
    /// </summary>
    /// <typeparam name="TModel">The type of model to analyze.</typeparam>
    /// <param name="strategy">Th estrategy to utilize when diagnosing models.</param>
    /// <returns>A new diagnostic provider.</returns>
    public static IDiagnosticProvider<TModel> Create<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> strategy) =>
        new Strategy<TModel>(strategy);
    /// <summary>
    /// Creates a new diagnostic provider.
    /// </summary>
    /// <typeparam name="TModel">The type of model to analyze.</typeparam>
    /// <param name="strategy">Th estrategy to utilize when diagnosing models.</param>
    /// <returns>A new diagnostic provider.</returns>
    public static IDiagnosticProvider<TModel> Create<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>> strategy) =>
        new Strategy<TModel>((model, diagnostics, token) =>
        {
            token.ThrowIfCancellationRequested();
            strategy.Invoke(model, diagnostics);
        });
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticProvider.Strategy.cs";
#endif
c.AddSource(
    "DiagnosticProvider.Strategye370d540_ff72_4962_a34c_9109cb2bb25c.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

partial class DiagnosticProvider
{
    internal sealed class Strategy<TModel>(Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> strategy) : IDiagnosticProvider<TModel>
    {
        private readonly Action<TModel, IDiagnosticsAccumulator<TModel>, CancellationToken> _strategy = strategy;

        public void Diagnose(TModel model, IDiagnosticsAccumulator<TModel> accumulator, CancellationToken cancellationToken = default) => 
            _strategy.Invoke(model, accumulator, cancellationToken);
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticsAccumulator.cs";
#endif
c.AddSource(
    "DiagnosticsAccumulator45943e33_dfe1_4cb9_acb5_7797254667d7.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

/// <summary>
/// Contains factory and extension methods for diagnostic accumulators.
/// </summary>
static partial class DiagnosticsAccumulator
{
    /// <summary>
    /// Creates a new diagnostic accumulator.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="model">The model to diagnose.</param>
    /// <returns>A new diagnostic accumulator.</returns>
    public static IDiagnosticsAccumulator<TModel> Create<TModel>(TModel model) =>
        new Impl<TModel>(model);

    /// <summary>
    /// Applies a filter to the diagnostic accumulator that discards all hidden diagnostics.
    /// This will prevent diagnostics from being added to the accumulator if they have a severity of <see cref="DiagnosticSeverity.Hidden"/>.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> DiagnoseNonHiddenSeverities<TModel>(this IDiagnosticsAccumulator<TModel> accumulator) =>
        accumulator
        .DiagnoseSeverity(DiagnosticSeverity.Info)
        .DiagnoseSeverity(DiagnosticSeverity.Warning)
        .DiagnoseSeverity(DiagnosticSeverity.Error);
    /// <summary>
    /// Applies a filter to the diagnostic accumulator that discards all diagnostics not registered to be diagnosed.
    /// This will prevent diagnostics from being added to the accumulator if they do not have a registered severity.
    /// Calls to this filter may be chained for registering a set of diagnosable severities.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <param name="severity">The diagnostics severity to register as diagnosable.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> DiagnoseSeverity<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, DiagnosticSeverity severity) =>
        accumulator is DiagnosisFilter<TModel> decorator ?
            decorator.AddSeverity(severity) :
            new DiagnosisFilter<TModel>(accumulator, severity);

    /// <summary>
    /// Receives diagnostics providers for generating diagnostics on the model.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="providers">The providers to generate diagnostics with.</param>
    /// <param name="accumulator">The accumulator to receive the providers.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference tothe accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> Receive<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, IEnumerable<IDiagnosticProvider<TModel>> providers, CancellationToken cancellationToken = default) =>
        providers.Aggregate(accumulator, (d, p) => d.Receive(p, cancellationToken));

    /// <summary>
    /// Applies a filter to the diagnostic accumulator that reports only non hidden diagnostics.
    /// This will cause diagnostics with the severity <see cref="DiagnosticSeverity.Hidden"/> not to be reported, however they will still be added to the accumulator.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> ReportNonHiddenSeverities<TModel>(this IDiagnosticsAccumulator<TModel> accumulator) =>
        accumulator
        .ReportSeverity(DiagnosticSeverity.Info)
        .ReportSeverity(DiagnosticSeverity.Warning)
        .ReportSeverity(DiagnosticSeverity.Error);
    /// <summary>
    /// Applies a filter to the accumulator that reports only diagnostics whose location is <see cref="Location.None"/>.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> ReportOnlyNoneLocations<TModel>(this IDiagnosticsAccumulator<TModel> accumulator) =>
        accumulator is LocationFilter<TModel> filter ?
            filter :
            new LocationFilter<TModel>(accumulator);
    /// <summary>
    /// Applies a filter to the diagnostic accumulator that reports only diagnostics with registered severities.
    /// This will cause diagnostics without a registered severity not to be reported, however they will still be added to the accumulator.
    /// Calls to this filter may be chained for registering a set of reportable severities.
    /// </summary>
    /// <typeparam name="TModel">The type of model to diagnose.</typeparam>
    /// <param name="accumulator">The accumulator to apply the filter to.</param>
    /// <param name="severity">The diagnostics severity to register as reportable.</param>
    /// <returns>A reference to the filtered accumulator, for chaining of further method calls.</returns>
    public static IDiagnosticsAccumulator<TModel> ReportSeverity<TModel>(this IDiagnosticsAccumulator<TModel> accumulator, DiagnosticSeverity severity) =>
        accumulator is ReportFilter<TModel> decorator ?
            decorator.AddSeverity(severity) :
            new ReportFilter<TModel>(accumulator, severity);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticsAccumulator.DiagnosisFilter.cs";
#endif
c.AddSource(
    "DiagnosticsAccumulator.DiagnosisFilter49f0f038_5e5d_4b11_b6fc_f11c35a0d558.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class DiagnosisFilter<TModel>(IDiagnosticsAccumulator<TModel> decoratedAccumulator, DiagnosticSeverity severity) : IDiagnosticsAccumulator<TModel>
    {
        private readonly IDiagnosticsAccumulator<TModel> _decoratedAccumulator = decoratedAccumulator;
        private readonly HashSet<DiagnosticSeverity> _severities = [severity];

        public IDiagnosticsAccumulator<TModel> AddSeverity(DiagnosticSeverity severity)
        {
            if(_severities.Contains(severity))
            {
                return this;
            }

            var result = new DiagnosisFilter<TModel>(_decoratedAccumulator, severity);
            foreach(var s in _severities)
            {
                _ = result._severities.Add(s);
            }

            return result;
        }

        public Boolean ContainsErrors => _decoratedAccumulator.ContainsErrors;

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic) =>
            _severities.Contains(diagnostic.Severity) ?
            _decoratedAccumulator.Add(diagnostic) :
            this;

        public void ReportDiagnostics(Action<Diagnostic> report) => _decoratedAccumulator.ReportDiagnostics(report);
        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            _ = _decoratedAccumulator.Receive(provider, cancellationToken);
            return this;
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticsAccumulator.Impl.cs";
#endif
c.AddSource(
    "DiagnosticsAccumulator.Implbe4c394e_2d21_4a85_85ab_1d4642b50a5b.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class Impl<TModel>(TModel model) :
    IDiagnosticsAccumulator<TModel>
    {
        private readonly List<Diagnostic> _diagnostics = [];
        private readonly TModel _model = model;

        public Boolean ContainsErrors { get; private set; }

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic)
        {
            _diagnostics.Add(diagnostic);

            if(diagnostic.Severity == DiagnosticSeverity.Error)
            {
                ContainsErrors = true;
            }

            return this;
        }

        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            provider.Diagnose(_model, this, cancellationToken);
            return this;
        }
        public void ReportDiagnostics(Action<Diagnostic> report)
        {
            foreach(var diagnostic in _diagnostics)
            {
                report.Invoke(diagnostic);
            }
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticsAccumulator.LocationFilter.cs";
#endif
c.AddSource(
    "DiagnosticsAccumulator.LocationFilter1856434f_c8cc_439f_80b4_3af7c60aa91d.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

static partial class DiagnosticsAccumulator
{
    sealed class LocationFilter<TModel>(IDiagnosticsAccumulator<TModel> proxied) : IDiagnosticsAccumulator<TModel>
    {
        private readonly IDiagnosticsAccumulator<TModel> _proxied = proxied;

        public Boolean ContainsErrors => _proxied.ContainsErrors;

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic)
        {
            _ = _proxied.Add(diagnostic);
            return this;
        }

        public void ReportDiagnostics(Action<Diagnostic> report) => _proxied.ReportDiagnostics(d =>
        {
            if(d.Location == Location.None)
                report.Invoke(d);
        });
        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            _ = _proxied.Receive(provider, cancellationToken);
            return this;
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\DiagnosticsAccumulator.ReportFilter.cs";
#endif
c.AddSource(
    "DiagnosticsAccumulator.ReportFilter3d0cfafb_b760_495c_a262_1b7aae09e353.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

partial class DiagnosticsAccumulator
{
    internal sealed class ReportFilter<TModel>(IDiagnosticsAccumulator<TModel> decoratedAccumulator, DiagnosticSeverity severity) : IDiagnosticsAccumulator<TModel>
    {
        private readonly IDiagnosticsAccumulator<TModel> _decoratedAccumulator = decoratedAccumulator;
        private readonly HashSet<DiagnosticSeverity> _severities = [severity];

        public IDiagnosticsAccumulator<TModel> AddSeverity(DiagnosticSeverity severity)
        {
            if(_severities.Contains(severity))
            {
                return this;
            }

            var result = new ReportFilter<TModel>(_decoratedAccumulator, severity);
            foreach(var s in _severities)
            {
                _ = result._severities.Add(s);
            }

            return result;
        }

        public Boolean ContainsErrors => _decoratedAccumulator.ContainsErrors;

        public IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic) => _decoratedAccumulator.Add(diagnostic);
        public void ReportDiagnostics(Action<Diagnostic> report) => _decoratedAccumulator.ReportDiagnostics(d =>
        {
            if(_severities.Contains(d.Severity))
            {
                report.Invoke(d);
            }
        });
        public IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default)
        {
            _ = _decoratedAccumulator.Receive(provider, cancellationToken);
            return this;
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EnumerableExtensions.cs";
#endif
c.AddSource(
    "EnumerableExtensionsde233d0b_841a_4d0a_bd3f_49de8f545c48.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System.Collections.Immutable;

static partial class EnumerableExtensions
{
    public static EquatableList<T> ToEquatableList<T>(this IEnumerable<T> values, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        if(values is EquatableList<T> equatable)
            return equatable;

        if(values is IReadOnlyList<T> list)
            return new(list);

        var result = new List<T>();
        foreach(var value in values)
        {
            cancellationToken.ThrowIfCancellationRequested();
            result.Add(value);
        }

        return new(result);
    }
    public static EquatableSet<T> ToEquatableSet<T>(this IEnumerable<T> values, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        if(values is EquatableSet<T> equatable)
            return equatable;

        if(values is IImmutableSet<T> list)
            return new(list);

        var resultBuilder = ImmutableHashSet.CreateBuilder<T>();
        foreach(var value in values)
        {
            cancellationToken.ThrowIfCancellationRequested();
            _ = resultBuilder.Add(value);
        }

        var result = resultBuilder.ToImmutable();

        return new(result);
    }
    public static EquatableSet<T> AsEquatable<T>(this IImmutableSet<T> set) =>
        set is EquatableSet<T> equatable ?
        equatable :
        new(set);
    public static EquatableList<T> AsEquatable<T>(this IReadOnlyList<T> list) =>
        list is EquatableList<T> equatable ?
        equatable :
        new(list);
    public static EquatableDictionary<TKey, TValue> AsEquatable<TKey, TValue>(this IReadOnlyDictionary<TKey, TValue> list) =>
        list is EquatableDictionary<TKey, TValue> equatable ?
        equatable :
        new(list);
    public static void Deconstruct<TKey, TValue>(this KeyValuePair<TKey, TValue> kvp, out TKey key, out TValue value) =>
        (key, value) = (kvp.Key, kvp.Value);
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EqualityComparerStrategy.cs";
#endif
c.AddSource(
    "EqualityComparerStrategy110f4dbc_c1ab_47f4_b01e_34a24d0a5d20.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

sealed class EqualityComparerStrategy<T>(Func<T, T, Boolean> equalsStrategy, Func<T, Int32> getHashCodeStrategy) : IEqualityComparer<T>
{
    private readonly Func<T, T, Boolean> _equalsStrategy = equalsStrategy;
    private readonly Func<T, Int32> _getHashCodeStrategy = getHashCodeStrategy;

    public Boolean Equals(T x, T y) => _equalsStrategy.Invoke(x, y);
    public Int32 GetHashCode(T obj) => _getHashCodeStrategy.Invoke(obj);
}

static class EqualityComparerStrategy
{
    public static IEqualityComparer<T> Create<T, TElement>(Func<T, TElement> elementSelector, IEqualityComparer<TElement> comparer) =>
        new EqualityComparerStrategy<T>(
            (x, y) => comparer.Equals(elementSelector.Invoke(x), elementSelector.Invoke(y)),
            obj => comparer.GetHashCode(elementSelector.Invoke(obj)));
    public static IEqualityComparer<T> Create<T, TElement>(Func<T, TElement> elementSelector) => Create(elementSelector, EqualityComparer<TElement>.Default);
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EquatableDictionary.cs";
#endif
c.AddSource(
    "EquatableDictionary4f9324d8_7830_4b86_a1d8_590a30f8d6f6.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System.Collections;

sealed class EquatableDictionary<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> decorated) :
    IReadOnlyDictionary<TKey, TValue>, IEquatable<EquatableDictionary<TKey, TValue>?>
{
    private readonly IReadOnlyDictionary<TKey, TValue> _decorated = decorated;
    private readonly EqualityComparer<TValue> _valueComparer = EqualityComparer<TValue>.Default;
    private readonly EqualityComparer<TKey> _keyComparer = EqualityComparer<TKey>.Default;

    public Boolean ContainsKey(TKey key) => _decorated.ContainsKey(key);
    public Boolean TryGetValue(TKey key, out TValue value) => _decorated.TryGetValue(key, out value);

    public TValue this[TKey key] => _decorated[key];

    public IEnumerable<TKey> Keys => _decorated.Keys;

    public IEnumerable<TValue> Values => _decorated.Values;

    public Int32 Count => _decorated.Count;

    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => _decorated.GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable)_decorated).GetEnumerator();
    public override Boolean Equals(Object? obj) => Equals(obj as EquatableDictionary<TKey, TValue>);
    public Boolean Equals(EquatableDictionary<TKey, TValue>? other)
    {
        if(other is null || Count != other.Count)
            return false;

        foreach(var (key, value) in _decorated)
        {
            if(!other.TryGetValue(key, out var otherValue) ||
               !_valueComparer.Equals(value, otherValue))
            {
                return false;
            }
        }

        return true;
    }

    public override Int32 GetHashCode()
    {
        var sum = 0;

        foreach(var (key, value) in _decorated)
        {
            var hashCode = 594671118;
            hashCode = hashCode * -1521134295 + _keyComparer.GetHashCode(key);
            hashCode = hashCode * -1521134295 + _valueComparer.GetHashCode(value);

            sum += hashCode;
        }

        return sum;
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EquatableList.cs";
#endif
c.AddSource(
    "EquatableListf3d827d3_155f_4d31_83a6_3f7e534788a6.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System.Collections;

sealed class EquatableList<T>(IReadOnlyList<T> decorated) : IReadOnlyList<T>, IEquatable<EquatableList<T>?>
{
    public static EquatableList<T> Empty { get; } = new(Array.Empty<T>());

    private readonly IReadOnlyList<T> _decorated = decorated;

    public T this[Int32 index] => _decorated[index];
    public Int32 Count => _decorated.Count;

    public override Boolean Equals(Object? obj) =>
        Equals(obj as EquatableList<T>);
    public Boolean Equals(EquatableList<T>? other) =>
        other is not null &&
        Count == other.Count &&
        _decorated.SequenceEqual(other._decorated);
    public IEnumerator<T> GetEnumerator() => _decorated.GetEnumerator();

    public override Int32 GetHashCode()
    {
        var hashCode = 594671118;
        for(var i = 0; i < _decorated.Count; i++)
        {
            hashCode = hashCode * -1521134295 + EqualityComparer<T>.Default.GetHashCode(_decorated[i]);
        }

        return hashCode;
    }

    IEnumerator IEnumerable.GetEnumerator() => _decorated.GetEnumerator();
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EquatableSet.cs";
#endif
c.AddSource(
    "EquatableSet75120d7a_f292_43f9_933c_a111a583b32b.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System.Collections;
using System.Collections.Immutable;

sealed class EquatableSet<T>(IImmutableSet<T> decorated) : IImmutableSet<T>, IEquatable<EquatableSet<T>?>
{
    private readonly IImmutableSet<T> _decorated = decorated;
    public Int32 Count => _decorated.Count;

    public IImmutableSet<T> Add(T value) => _decorated.Add(value);
    public IImmutableSet<T> Clear() => _decorated.Clear();
    public Boolean Contains(T value) => _decorated.Contains(value);
    public override Boolean Equals(Object? obj) =>
        Equals(obj as EquatableSet<T>);
    public Boolean Equals(EquatableSet<T>? other) =>
        other is not null &&
        Count == other.Count &&
        _decorated.All(other._decorated.Contains);
    public IImmutableSet<T> Except(IEnumerable<T> other) => _decorated.Except(other);
    public IEnumerator<T> GetEnumerator() => _decorated.GetEnumerator();

    public override Int32 GetHashCode()
    {
        var hashCode = 594671118;
        foreach(var element in _decorated)
        {
            hashCode = hashCode * -1521134295 + EqualityComparer<T>.Default.GetHashCode(element);
        }

        return hashCode;
    }

    public IImmutableSet<T> Intersect(IEnumerable<T> other) => _decorated.Intersect(other);
    public Boolean IsProperSubsetOf(IEnumerable<T> other) => _decorated.IsProperSubsetOf(other);
    public Boolean IsProperSupersetOf(IEnumerable<T> other) => _decorated.IsProperSupersetOf(other);
    public Boolean IsSubsetOf(IEnumerable<T> other) => _decorated.IsSubsetOf(other);
    public Boolean IsSupersetOf(IEnumerable<T> other) => _decorated.IsSupersetOf(other);
    public Boolean Overlaps(IEnumerable<T> other) => _decorated.Overlaps(other);
    public IImmutableSet<T> Remove(T value) => _decorated.Remove(value);
    public Boolean SetEquals(IEnumerable<T> other) => _decorated.SetEquals(other);
    public IImmutableSet<T> SymmetricExcept(IEnumerable<T> other) => _decorated.SymmetricExcept(other);
    public Boolean TryGetValue(T equalValue, out T actualValue) => _decorated.TryGetValue(equalValue, out actualValue);
    public IImmutableSet<T> Union(IEnumerable<T> other) => _decorated.Union(other);
    IEnumerator IEnumerable.GetEnumerator() => _decorated.GetEnumerator();
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\EquatedData.cs";
#endif
c.AddSource(
    "EquatedData6c091568_9c8a_4092_baaf_d95fd9102907.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

readonly struct EquatedData<T>(T value) : IEquatable<EquatedData<T>>
{
    public readonly T Value = value;

    private static readonly Int32 _hashCode = typeof(T).GetHashCode();

    public Boolean Equals(EquatedData<T> other) => true;
    public override Boolean Equals(Object obj) =>
        obj is EquatedData<T> other
        && Equals(other);
    public override Int32 GetHashCode() => _hashCode;

    public static implicit operator T(EquatedData<T> data) => data.Value;
    public static implicit operator EquatedData<T>(T value) => new(value);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder034085a3_5528_4850_835c_eee312e6dac6.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

/// <summary>
/// Represents an action appending to an expanding macro string builder.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <param name="builder">The builder to append to.</param>
/// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
delegate void Appendix<TMacro>(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken);

/// <summary>
/// Represents an action appending to an expanding macro string builder.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <typeparam name="TModel">The type of model to pass to the appendix.</typeparam>
/// <param name="builder">The builder to append to.</param>
/// <param name="model">The model to pass to the appendix.</param>
/// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
delegate void Appendix<TMacro, TModel>(IExpandingMacroStringBuilder<TMacro> builder, TModel model, CancellationToken cancellationToken);

/// <summary>
/// Contains factory and extension methods for expanding macro string builders.
/// </summary>
static partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Creates a new expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="providers">An optional collection of expansion providers to initialize the builder with.</param>
    /// <returns>A new expanding macro string builder.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Create<TMacro>(params IMacroExpansion<TMacro>[] providers) =>
        providers.Aggregate(Create<TMacro>(), static (b, w) => b.Receive(w, default));
    /// <summary>
    /// Creates a new expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <returns>A new expanding macro string builder.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Create<TMacro>() => Impl<TMacro>.Create();
    /// <summary>
    /// Applies an error intercepting proxy to an expanding macro string builder.
    /// Upon the diagnostics accumulator provided reporting errors, no further appendices 
    /// will be passed through to the underlying builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model diagnosed by the diagnostics.</typeparam>
    /// <param name="builder">The builder to apply error interception to.</param>
    /// <param name="diagnostics">The diagnostics based on which to intercept appendices.</param>
    /// <returns>A new reference to the proxy, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> InterceptErrors<TMacro, TModel>(this IExpandingMacroStringBuilder<TMacro> builder, IDiagnosticsAccumulator<TModel> diagnostics) =>
        ErrorProxy<TMacro, TModel>.Apply(builder, diagnostics);
    /// <summary>
    /// Applies a formatting decorator to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to apply formatting to.</param>
    /// <param name="options">The options to use when formatting.</param>
    /// <returns>A new reference to the decorator, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Format<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        CSharpBuilderFormattingOptions? options = null)
    {
        options ??= CSharpBuilderFormattingOptions.Default;

        if(builder is CSharpFormatter<TMacro> decorator)
        {
            return decorator.WithOptions(options.Value);
        }

        return new CSharpFormatter<TMacro>(builder, options.Value);
    }

    /// <summary>
    /// Registers an expansion provider to the builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to register the provider to.</param>
    /// <param name="macro">The macro to expansion text for using the provider registered.</param>
    /// <param name="strategy">The strategy using which to write expansion text to a string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Receive<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Receive(MacroExpansion.Create(macro, strategy), cancellationToken);
    }
    /// <summary>
    /// Registers a collection of expansion providers to the builder.
    /// </summary>
    /// <param name="builder">The builder to append expansion providers to.</param>
    /// <param name="providers">The providers to register.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Receive<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IEnumerable<IMacroExpansion<TMacro>> providers,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = providers ?? throw new ArgumentNullException(nameof(providers));

        foreach(var provider in providers)
        {
            builder = builder.Receive(provider, cancellationToken);
        }

        return builder;
        ;
    }
    /// <summary>
    /// Appends an appendix to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the appendix to.</param>
    /// <param name="appendix">The appendix to append to the builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Append<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Appendix<TMacro> appendix,
        CancellationToken cancellationToken)
    {
        appendix.Invoke(builder, cancellationToken);
        return builder;
    }
    /// <summary>
    /// Appends an appendix to an expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model to pass to the appendix.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="model">The model to pass to the appendix.</param>
    /// <param name="appendix">The appendix to append to the builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> Append<TMacro, TModel>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Appendix<TMacro, TModel> appendix,
        TModel model,
        CancellationToken cancellationToken)
    {
        appendix.Invoke(builder, model, cancellationToken);
        return builder;
    }
    /// <summary>
    /// Creates a decorator around the provided builder enabling the use of operators instead of append, append macro and receive.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to decorate.</param>
    /// <param name="cancellationToken">
    /// The cancellation token used to signal expansion to cancel.
    /// This token will be ambiently passed to calls backing the operators provided.
    /// </param>
    /// <returns>The new decorator.</returns>
    public static OperatorsDecorator<TMacro> WithOperators<TMacro>(this IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken) =>
        OperatorsDecorator<TMacro>.Create(builder, cancellationToken);
    /// <summary>
    /// Creates a decorator around the provided builder enabling the use of operators instead of append, append macro and receive.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model to support appendices for.</typeparam>
    /// <param name="builder">The builder to decorate.</param>
    /// <param name="cancellationToken">
    /// The cancellation token used to signal expansion to cancel.
    /// This token will be ambiently passed to calls backing the operators provided.
    /// </param>
    /// <returns>The new decorator.</returns>
    public static OperatorsDecorator<TMacro, TModel> WithOperators<TMacro, TModel>(this IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken) =>
        OperatorsDecorator<TMacro, TModel>.Create(builder, cancellationToken);
    #region Append Value
    /// <summary>
    /// Appends to the builder a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append('\n');
    }
    /// <summary>
    /// Appends a generator marker attribute, as well as a pragma for dsabling all warnings to the builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the header to.</param>
    /// <param name="generatorName">The name of the generator, for adding a meaningful comment.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendHeader<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String generatorName)
        => builder.AppendLine("// <auto-generated>")
        .Append("// This file was last generated by the ").Append(generatorName).Append(" on ").AppendLine(DateTimeOffset.Now.ToString())
        .AppendLine("// </auto-generated>")
        .AppendLine("#pragma warning disable");
    /// <summary>
    /// Appends to the builder a string value, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="value">The value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String value)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append(value).AppendLine();
    }

    /// <summary>
    /// Appends to the builder a character value, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="value">The value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char value)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.Append(value).AppendLine();
    }

    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The string to use as a separator.</param>
    /// <param name="values">An enumeration containing values to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String separator,
        IEnumerable<T> values)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The character to use as a separator.</param>
    /// <param name="values">An enumeration containing values to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char separator,
        IEnumerable<T> values)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration. 
    /// An expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return values.Aggregate(builder, (b, e) => aggregation.Invoke(b, e, cancellationToken));
    }

    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// An expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The string to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        String separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// An expanding macro string builder is used as the initial accumulator value.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The character to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        Char separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.Append(separator);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    #endregion
    #region Append Macro
    /// <summary>
    /// Appends all values from an enumeration type macro to an expanding macro string builder.
    /// The macro values will be appended in ascending order.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append macros to.</param>
    /// <param name="comparer">The comparer to use when ordering macro values.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacros<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        IComparer<TMacro> comparer,
        CancellationToken cancellationToken = default)
        where TMacro : struct, Enum
    {
        var result = Enum.GetValues(typeof(TMacro))
            .OfType<TMacro>()
            .OrderBy(m => m, comparer)
            .Aggregate(builder, (b, p) => b.AppendMacro(p, cancellationToken));

        return result;
    }
    /// <summary>
    /// Appends all values from an enumeration type macro to an expanding macro string builder.
    /// The macro values will be appended in ascending order.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append macros to.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacros<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        CancellationToken cancellationToken = default)
        where TMacro : struct, Enum => builder.AppendMacros(Comparer<TMacro>.Default, cancellationToken);
    /// <summary>
    /// Appends to the builder a macro, followed by a single newline character.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append to.</param>
    /// <param name="macro">The macro to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroLine<TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro macro,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));

        return builder.AppendMacro(macro, cancellationToken).AppendLine();
    }

    /// <summary>
    /// Using an expanding macro string builder, appends the elements of an enumeration, inserting
    /// the specified separator between the elements.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to append the separated elements to.</param>
    /// <param name="separator">The macro to use as a separator.</param>
    /// <param name="values">An enumeration containing macros to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro separator,
        IEnumerable<T> values,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        _ = builder.Append(iterator.Current?.ToString() ?? String.Empty);

        while(iterator.MoveNext())
        {
            _ = builder.AppendMacro(separator, cancellationToken)
                .Append(iterator.Current?.ToString() ?? String.Empty);
        }

        return builder;
    }
    /// <summary>
    /// Applies an aggregation function over an enumeration, separating 
    /// aggregation results with the separator specified.
    /// An expanding macro string builder is used as the initial accumulator macro.
    /// </summary>
    /// <typeparam name="T">The type of element contained in the enumeration.</typeparam>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The builder to aggregate elements in.</param>
    /// <param name="separator">The macro to use as a separator.</param>
    /// <param name="values">The elements to aggregate in the builder.</param>
    /// <param name="aggregation">The aggregation function to apply.</param>
    /// <param name="cancellationToken">The cancellation token used to signal the source generation to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further method calls.</returns>
    public static IExpandingMacroStringBuilder<TMacro> AppendMacroJoin<T, TMacro>(
        this IExpandingMacroStringBuilder<TMacro> builder,
        TMacro separator,
        IEnumerable<T> values,
        Func<IExpandingMacroStringBuilder<TMacro>, T, CancellationToken, IExpandingMacroStringBuilder<TMacro>> aggregation,
        CancellationToken cancellationToken = default)
    {
        _ = builder ?? throw new ArgumentNullException(nameof(builder));
        _ = values ?? throw new ArgumentNullException(nameof(values));
        _ = aggregation ?? throw new ArgumentNullException(nameof(aggregation));

        using var iterator = values.GetEnumerator();

        if(iterator == null || !iterator.MoveNext())
        {
            return builder;
        }

        builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);

        while(iterator.MoveNext())
        {
            _ = builder.AppendMacro(separator, cancellationToken);
            builder = aggregation.Invoke(builder, iterator.Current, cancellationToken);
        }

        return builder;
    }
    #endregion
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.CSharpFormatter.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.CSharpFormattere76c90f1_b0ee_4379_ae40_a28c099c2407.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System;
using System.Collections.Generic;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Formats the build output of the decorated expanding macro string builder.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <param name="builder">The expanding macro string builder to decorate.</param>
    /// <param name="options">The options to use when formatting generated source text.</param>
    internal sealed class CSharpFormatter<TMacro>(
        IExpandingMacroStringBuilder<TMacro> builder,
        CSharpBuilderFormattingOptions options) :
        IExpandingMacroStringBuilder<TMacro>,
        IEquatable<CSharpFormatter<TMacro>?>
    {
        private readonly IExpandingMacroStringBuilder<TMacro> _decoratedBuilder = builder;
        private readonly CSharpBuilderFormattingOptions _options = options;

        /// <summary>
        /// Creates a new formatting decorator decorating the same builder, but using the provided options.
        /// </summary>
        /// <param name="newOptions">The options to be used by the new formatting decorator.</param>
        /// <returns>A new formatting decorator.</returns>
        public CSharpFormatter<TMacro> WithOptions(CSharpBuilderFormattingOptions newOptions) =>
            new(_decoratedBuilder, newOptions);

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            _ = _decoratedBuilder.Append(value);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            _ = _decoratedBuilder.Append(value);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            _ = _decoratedBuilder.AppendMacro(macro, cancellationToken);

            return this;
        }

        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> writer, CancellationToken cancellationToken = default)
        {
            _ = _decoratedBuilder.Receive(writer, cancellationToken);

            return this;
        }

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default) =>
            CSharpSyntaxTree.ParseText(
                text: _decoratedBuilder.Build(cancellationToken),
                options: _options.ParseOptions,
                cancellationToken: cancellationToken)
                .GetRoot(cancellationToken)
                .NormalizeWhitespace(
                    indentation: _options.Indentation,
                    eol: _options.EndOfLine,
                    elasticTrivia: _options.ElasticTrivia)
                .SyntaxTree
                .GetText(cancellationToken)
                .ToString();
        /// <inheritdoc/>
        public override String ToString() => _decoratedBuilder.ToString();
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) => Equals(obj as CSharpFormatter<TMacro>);
        /// <inheritdoc/>
        public Boolean Equals(CSharpFormatter<TMacro>? other) =>
            other is not null &&
            EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_decoratedBuilder, other._decoratedBuilder);
        /// <inheritdoc/>
        public override Int32 GetHashCode() => 1679842278 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_decoratedBuilder);
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.ErrorProxy.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.ErrorProxyf7c3550e_16fc_4621_9890_64addcd485fb.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Proxies operations on an expanding macro string builder against error diagnostics. 
    /// Operations will only be passed through if no errors have been diagnosed 
    /// to the diagnostics accumulator provided.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model whose diagnostics to query.</typeparam>
    /// <param name="proxied">The expanding macro string builder to proxy.</param>
    /// <param name="diagnostics">The diagnostics accumulator to query for errors when intercepting operations.</param>
    internal sealed class ErrorProxy<TMacro, TModel>(
        IExpandingMacroStringBuilder<TMacro> proxied,
        IDiagnosticsAccumulator<TModel> diagnostics) :
        IExpandingMacroStringBuilder<TMacro>,
        IEquatable<ErrorProxy<TMacro, TModel>?>
    {
        private readonly IExpandingMacroStringBuilder<TMacro> _proxied = proxied;
        private readonly IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default) => _proxied.Build(cancellationToken);
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Append(value);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.AppendMacro(macro, cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default)
        {
            if(!_diagnostics.ContainsErrors)
            {
                _ = _proxied.Receive(provider, cancellationToken);
            }

            return this;
        }
        /// <summary>
        /// Creates a new proxy for the builder provided, if it is not already an error proxy using the diagnostics provided.
        /// </summary>
        /// <param name="builder">The builder to conditionally proxy.</param>
        /// <param name="diagnostics">The diagnostics based on which to intercept appendices.</param>
        /// <returns>
        /// The new proxy if the builder provided is not already an error proxy using the diagnostics 
        /// provided; otherwise, a reference to the builder, for chaining of further method calls.
        /// </returns>
        public static IExpandingMacroStringBuilder<TMacro> Apply(IExpandingMacroStringBuilder<TMacro> builder, IDiagnosticsAccumulator<TModel> diagnostics)
        {
            if(builder is not ErrorProxy<TMacro, TModel> proxy || 
               !EqualityComparer<IDiagnosticsAccumulator<TModel>>.Default.Equals(proxy._diagnostics, diagnostics))
            {
                proxy = new ErrorProxy<TMacro, TModel>(builder, diagnostics);
            }

            return proxy;
        }
        /// <inheritdoc/>
        public override String ToString() => _proxied.ToString();
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) =>
            Equals(obj as ErrorProxy<TMacro, TModel>);
        /// <inheritdoc/>
        public Boolean Equals(ErrorProxy<TMacro, TModel>? other) =>
            other is not null && EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_proxied, other._proxied);
        /// <inheritdoc/>
        public override Int32 GetHashCode() =>
            -305811549 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_proxied);
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.Impl.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.Impl63cdd135_9106_4997_9567_49c57bd033ef.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;
using System.Text;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Default implementation of <see cref="IExpandingMacroStringBuilder{TMacro}"/>.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support expansion for.</typeparam>
    internal sealed partial class Impl<TMacro> : IExpandingMacroStringBuilder<TMacro>
    {
        private Impl(
            Boolean isRoot,
            Queue<StringOrChar, TMacro> template,
            ExpansionObserver expansionObserver,
            Dictionary<TMacro, IMacroExpansion<TMacro>> expansionMap,
            StringBuilder builder)
        {
            _isRoot = isRoot;
            _template = template;
            _expansionObserver = expansionObserver;
            _expansionMap = expansionMap;
            _builder = builder;
        }

        private readonly Queue<StringOrChar, TMacro> _template;
        private readonly Dictionary<TMacro, IMacroExpansion<TMacro>> _expansionMap;
        private readonly ExpansionObserver _expansionObserver;
        private readonly StringBuilder _builder;
        private readonly Boolean _isRoot;

        /// <summary>
        /// Creates a new instance of the builder.
        /// </summary>
        /// <returns>A new builder instance.</returns>
        public static IExpandingMacroStringBuilder<TMacro> Create() =>
            new Impl<TMacro>(
                isRoot: true,
                template: new(),
                expansionObserver: ExpansionObserver.Create(),
                expansionMap: [],
                builder: new());
        private Impl<TMacro> Derive(Queue<StringOrChar, TMacro> template) =>
            new(
                isRoot: false,
                template: template,
                expansionObserver: _expansionObserver.Derive(),
                expansionMap: _expansionMap,
                builder: new());
        private Impl<TMacro> Clone()
        {
            return new(
                isRoot: true,
                template: _template.Clone(),
                expansionObserver: _expansionObserver.Clone(),
                expansionMap: _expansionMap,
                builder: _builder);
        }

        /// <inheritdoc/>
        public String Build(CancellationToken cancellationToken = default)
        {
            var clone = Clone();
            clone.Expand(cancellationToken);
            clone.Reduce(cancellationToken);
            if(clone._template.ContainsMacros)
            {
                var macros = _template.GetMacros();
                throw new UnexpandedMacrosException<TMacro>(macros);
            } else
            {
                return clone._builder.ToString();
            }
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(String value)
        {
            _ = _template.EnqueueValue(value);
            Reduce(default);
            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Append(Char value)
        {
            _ = _template.EnqueueValue(value);
            Reduce(default);
            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();

            _ = _template.EnqueueMacro(macro);
            if(_expansionMap.TryGetValue(macro, out var expansion))
            {
                Expand(expansion, cancellationToken);
                Reduce(cancellationToken);
            }

            return this;
        }
        /// <inheritdoc/>
        public IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if(!_isRoot)
            {
                //TODO
                throw new NotImplementedException("Providing macro expansions inside of macro expansions is not implemented yet.");
            }

            _expansionMap[provider.Macro] = provider;
            Expand(provider, cancellationToken);
            Reduce(cancellationToken);

            return this;
        }

        private void Expand(CancellationToken cancellationToken)
        {
            var expansions = _template.UnexpandedMacros()
                .Select(m => (HasExpansion: _expansionMap.TryGetValue(m, out var e), Expansion: e))
                .Where(t => t.HasExpansion);

            foreach(var (_, expansion) in expansions)
            {
                Expand(expansion, cancellationToken);
            }
        }
        private void Expand(IMacroExpansion<TMacro> expansion, CancellationToken cancellationToken)
        {
            _expansionObserver.NotifyExpansionStart(expansion.Macro);
            try
            {
                ExpansionObserver derivedObserver;
                do
                {
                    derivedObserver = _expansionObserver.Derive();
                    _ = _template.Expand(expansion.Macro, q => expansion.Expand(Derive(template: q), cancellationToken));
                } while(derivedObserver.Expanded);
            } finally
            {
                _expansionObserver.NotifyExpansionEnd(expansion.Macro);
            }
        }

        private void Reduce(CancellationToken cancellationToken)
        {
            if(!_isRoot)
            {
                return;
            }

            cancellationToken.ThrowIfCancellationRequested();

            var values = _template.DequeueValues();
            foreach(var value in values)
            {
                cancellationToken.ThrowIfCancellationRequested();

                _ = value.IsChar ?
                    _builder.Append(value.Char) :
                    _builder.Append(value.String);
            }
        }

        /// <inheritdoc/>
        public override String ToString() => $"({(_builder.Length > 0 ? _builder.ToString() : String.Empty)})-{_template}";
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.Impl.ExpansionObserver.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.Impl.ExpansionObserver7268948e_c1ff_45c9_ae2d_69178e3e11d5.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    partial class Impl<TMacro>
    {
        sealed class ExpansionObserver
        {
            private ExpansionObserver(HashSet<TMacro> recursionDetectionSet) => _recursionDetectionSet = recursionDetectionSet;

            public Boolean Expanded { get; private set; }
            private readonly HashSet<TMacro> _recursionDetectionSet;

            public static ExpansionObserver Create() => new([]);
            public ExpansionObserver Derive() => new(_recursionDetectionSet);
            public ExpansionObserver Clone() => new(new(_recursionDetectionSet))
            {
                Expanded = Expanded
            };

            public void NotifyExpansionStart(TMacro macro)
            {
                if(!_recursionDetectionSet.Add(macro))
                    throw new InfinitelyRecursingExpansionException<TMacro>(macro);
            }
            public void NotifyExpansionEnd(TMacro macro)
            {
                if(!_recursionDetectionSet.Remove(macro))
                    throw new ArgumentException($"Observer was not notified of {macro} expansion start.", nameof(macro));
                Expanded = true;
            }

            public override String ToString() => $"{(Expanded ? "Expanded" : "Not Expanded")} [{String.Join(",", _recursionDetectionSet)}]";
        }
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.Impl.StringOrChar.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.Impl.StringOrChard2132240_ac9c_4efe_bb85_e49194d75853.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

partial class ExpandingMacroStringBuilder
{
    partial class Impl<TMacro>
    {
        readonly struct StringOrChar
        {
            public readonly Char Char;
            public readonly String? String;
            public readonly Boolean IsChar;

            public StringOrChar(Char @char)
            {
                Char = @char;
                String = null;
                IsChar = true;
            }
            public StringOrChar(String @string)
            {
                Char = default;
                String = @string;
                IsChar = false;
            }

            public static implicit operator StringOrChar(String @string) => new(@string);
            public static implicit operator StringOrChar(Char @char) => new(@char);

            public override String ToString() => IsChar ? Char.ToString() : String!;
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.OperatorsDecorator.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.OperatorsDecorator11c2e8ea_12cc_4f84_8b43_9af68467b1c9.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

static partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Decorates an expanding macro string builder with operators for ease of use.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    public sealed partial class OperatorsDecorator<TMacro> : OperatorsDecoratorBase<TMacro, OperatorsDecorator<TMacro>>
    {
        private OperatorsDecorator(IExpandingMacroStringBuilder<TMacro> decorated, CancellationToken cancellationToken) : base(decorated, cancellationToken)
        {
        }

        /// <summary>
        /// Creates a new decorator or returns the provided builder if it already is a decorator.
        /// </summary>
        /// <param name="decorated">The builder to potentially wrap.</param>
        /// <param name="cancellationToken">The cancellation token to ambiently pass to calls to the decorated builder.</param>
        /// <returns>The potentially new decorator.</returns>
        public static OperatorsDecorator<TMacro> Create(IExpandingMacroStringBuilder<TMacro> decorated, CancellationToken cancellationToken) =>
            decorated is OperatorsDecorator<TMacro> decorator ?
            decorator :
            new(decorated, cancellationToken);
        protected override OperatorsDecorator<TMacro> GetSelf() => this;
    }
    /// <summary>
    /// Decorates an expanding macro string builder with operators for ease of use.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TModel">The type of model to support appendices for.</typeparam>
    public sealed partial class OperatorsDecorator<TMacro, TModel> : OperatorsDecoratorBase<TMacro, OperatorsDecorator<TMacro, TModel>>
    {
        private OperatorsDecorator(IExpandingMacroStringBuilder<TMacro> decorated, CancellationToken cancellationToken) : base(decorated, cancellationToken)
        {
        }

        /// <summary>
        /// Creates a new decorator or returns the provided builder if it already is a decorator.
        /// </summary>
        /// <param name="decorated">The builder to potentially wrap.</param>
        /// <param name="cancellationToken">The cancellation token to ambiently pass to calls to the decorated builder.</param>
        /// <returns>The potentially new decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> Create(IExpandingMacroStringBuilder<TMacro> decorated, CancellationToken cancellationToken) =>
            decorated is OperatorsDecorator<TMacro, TModel> decorator ?
            decorator :
            new(decorated, cancellationToken);
        protected override OperatorsDecorator<TMacro, TModel> GetSelf() => this;

        /// <summary>
        /// Applies a method to a decorator.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator *(OperatorsDecorator<TMacro, TModel> decorator, Action<OperatorsDecorator<TMacro, TModel>> action)
        {
            action.Invoke(decorator);
            return decorator;
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator *(OperatorsDecorator<TMacro, TModel> decorator, IEnumerable<Action<OperatorsDecorator<TMacro, TModel>>> actions)
        {
            foreach(var a in actions)
            {
                a.Invoke(decorator);
            }

            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a method to a decorator, appending a new line before applying the method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator /(OperatorsDecorator<TMacro, TModel> decorator, Action<OperatorsDecorator<TMacro, TModel>> action)
        {
            _ = decorator.AppendLine();
            action.Invoke(decorator);
            return decorator;
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator, appending a new line before applying a method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator /(OperatorsDecorator<TMacro, TModel> decorator, IEnumerable<Action<OperatorsDecorator<TMacro, TModel>>> actions)
        {
            foreach(var a in actions)
            {
                _ = decorator.AppendLine();
                a.Invoke(decorator);
            }

            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a method to a decorator, appending a new line after applying the method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator %(OperatorsDecorator<TMacro, TModel> decorator, Action<OperatorsDecorator<TMacro, TModel>> action)
        {
            action.Invoke(decorator);
            _ = decorator.AppendLine();
            return decorator;
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator, appending a new line after applying a method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static OperatorsDecorator<TMacro, TModel> operator %(OperatorsDecorator<TMacro, TModel> decorator, IEnumerable<Action<OperatorsDecorator<TMacro, TModel>>> actions)
        {
            foreach(var a in actions)
            {
                a.Invoke(decorator);
                _ = decorator.AppendLine();
            }

            return decorator.GetSelf();
        }
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.OperatorsDecoratorBase.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.OperatorsDecoratorBase6935945d_2ce6_4d4e_a732_c160e174940b.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

static partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Decorates an expanding macro string builder with operators for ease of use.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to support.</typeparam>
    /// <typeparam name="TSelf">The implementing type.</typeparam>
    public abstract class OperatorsDecoratorBase<TMacro, TSelf> : IExpandingMacroStringBuilder<TMacro>, IEquatable<OperatorsDecoratorBase<TMacro, TSelf>?> where TSelf : OperatorsDecoratorBase<TMacro, TSelf>
    {
        /// <summary>
        /// Intializes a new instance.
        /// </summary>
        /// <param name="decorated">The builder to decorate with operators.</param>
        /// <param name="cancellationToken">The cancellation token to ambiently pass to calls to the decorated builder.</param>
        protected OperatorsDecoratorBase(IExpandingMacroStringBuilder<TMacro> decorated, CancellationToken cancellationToken)
        {
            _decorated = decorated;
            CancellationToken = cancellationToken;
        }

        /// <summary>
        /// The decorated builder.
        /// </summary>
        private readonly IExpandingMacroStringBuilder<TMacro> _decorated;
        /// <summary>
        /// Gets the cancellation token to ambiently pass to calls to the decorated builder.
        /// </summary>
        public CancellationToken CancellationToken { get; }

        protected abstract TSelf GetSelf();
        /// <inheritdoc cref="IExpandingMacroStringBuilder{TMacro}.Append(String)"/>
        public TSelf Append(String value)
        {
            _ = _decorated.Append(value);
            return GetSelf();
        }
        /// <summary>
        /// Applies a mthod to the builder.
        /// </summary>
        /// <param name="method">The method to apply.</param>
        /// <returns>A reference to the builder, for chaining of further method calls.</returns>
        public TSelf Apply(Action<TSelf> method)
        {
            method.Invoke(GetSelf());
            return GetSelf();
        }
        /// <inheritdoc cref="IExpandingMacroStringBuilder{TMacro}.Append(Char)"/>
        public TSelf Append(Char value)
        {
            _ = _decorated.Append(value);
            return GetSelf();
        }
        /// <inheritdoc cref="IExpandingMacroStringBuilder{TMacro}.AppendMacro(TMacro, CancellationToken)"/>
        public TSelf AppendMacro(TMacro macro, CancellationToken cancellationToken)
        {
            _ = _decorated.AppendMacro(macro, cancellationToken);
            return GetSelf();
        }
        /// <inheritdoc cref="IExpandingMacroStringBuilder{TMacro}.Receive(IMacroExpansion{TMacro}, CancellationToken)"/>
        public TSelf Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken)
        {
            _ = _decorated.Receive(provider, cancellationToken);
            return GetSelf();
        }

        /// <inheritdoc/>
        IExpandingMacroStringBuilder<TMacro> IExpandingMacroStringBuilder<TMacro>.Append(String value) => Append(value);
        /// <inheritdoc/>
        IExpandingMacroStringBuilder<TMacro> IExpandingMacroStringBuilder<TMacro>.Append(Char value) => Append(value);
        /// <inheritdoc/>
        IExpandingMacroStringBuilder<TMacro> IExpandingMacroStringBuilder<TMacro>.AppendMacro(TMacro macro, CancellationToken cancellationToken) => AppendMacro(macro, cancellationToken);
        /// <inheritdoc/>
        IExpandingMacroStringBuilder<TMacro> IExpandingMacroStringBuilder<TMacro>.Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken) => Receive(provider, cancellationToken);
        /// <inheritdoc/>
        String IExpandingMacroStringBuilder<TMacro>.Build(CancellationToken cancellationToken) =>
            _decorated.Build(cancellationToken);

        /// <inheritdoc/>
        public String Build() => ((IExpandingMacroStringBuilder<TMacro>)this).Build(CancellationToken);

        /// <inheritdoc/>
        public override String ToString() => _decorated.ToString();
        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) => Equals(obj as OperatorsDecoratorBase<TMacro, TSelf>);
        /// <inheritdoc/>
        public Boolean Equals(OperatorsDecoratorBase<TMacro, TSelf>? other) => other is not null && EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.Equals(_decorated, other._decorated);
        /// <inheritdoc/>
        public override Int32 GetHashCode() => 47476743 + EqualityComparer<IExpandingMacroStringBuilder<TMacro>>.Default.GetHashCode(_decorated);

        /// <summary>
        /// Appends a string to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The string to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, String value) =>
            decorator.Append(value);
        /// <summary>
        /// Appends a character to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The character to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, Char value) =>
            decorator.Append(value);
        /// <summary>
        /// Appends a macro to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="macro">The macro to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, TMacro macro) =>
            decorator.AppendMacro(macro, decorator.CancellationToken);
        /// <summary>
        /// Registers a macro expansion to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="expansion">The expansion to be received by the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, IMacroExpansion<TMacro> expansion) =>
            decorator.Receive(expansion, decorator.CancellationToken);
        /// <summary>
        /// Applies a method to a decorator.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, Action<OperatorsDecoratorBase<TMacro, TSelf>> action)
        {
            action.Invoke(decorator);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator *(OperatorsDecoratorBase<TMacro, TSelf> decorator, IEnumerable<Action<OperatorsDecoratorBase<TMacro, TSelf>>> actions)
        {
            foreach(var a in actions)
            {
                a.Invoke(decorator);
            }

            return decorator.GetSelf();
        }

        /// <summary>
        /// Appends a string, preceded by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The string to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator /(OperatorsDecoratorBase<TMacro, TSelf> decorator, String value)
        {
            _ = decorator.AppendLine().Append(value);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Appends a character, preceded by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The character to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator /(OperatorsDecoratorBase<TMacro, TSelf> decorator, Char value)
        {
            _ = decorator.AppendLine().Append(value);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Appends a macro, preceded by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="macro">The macro to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator /(OperatorsDecoratorBase<TMacro, TSelf> decorator, TMacro macro)
        {
            _ = decorator.AppendLine().AppendMacro(macro);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a method to a decorator, appending a new line before applying the method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator /(OperatorsDecoratorBase<TMacro, TSelf> decorator, Action<OperatorsDecoratorBase<TMacro, TSelf>> action)
        {
            _ = decorator.AppendLine();
            action.Invoke(decorator);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator, appending a new line before applying a method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator /(OperatorsDecoratorBase<TMacro, TSelf> decorator, IEnumerable<Action<OperatorsDecoratorBase<TMacro, TSelf>>> actions)
        {
            foreach(var a in actions)
            {
                _ = decorator.AppendLine();
                a.Invoke(decorator);
            }

            return decorator.GetSelf();
        }

        /// <summary>
        /// Appends a string, followed by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The string to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator %(OperatorsDecoratorBase<TMacro, TSelf> decorator, String value)
        {
            _ = decorator.AppendLine(value);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Appends a character, followed by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="value">The character to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator %(OperatorsDecoratorBase<TMacro, TSelf> decorator, Char value)
        {
            _ = decorator.AppendLine(value);
            return decorator.GetSelf();
        }
        /// <summary>
        /// Appends a macro, followed by a new line, to the builder wrapped by the decorator provided.
        /// </summary>
        /// <param name="decorator">The decorator wrapping a builder.</param>
        /// <param name="macro">The macro to append to the builder wrapped by the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator %(OperatorsDecoratorBase<TMacro, TSelf> decorator, TMacro macro)
        {
            _ = decorator.AppendMacro(macro, decorator.CancellationToken).AppendLine();
            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a method to a decorator, appending a new line after applying the method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="action">The method to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator %(OperatorsDecoratorBase<TMacro, TSelf> decorator, Action<OperatorsDecoratorBase<TMacro, TSelf>> action)
        {
            action.Invoke(decorator);
            _ = decorator.AppendLine();
            return decorator.GetSelf();
        }
        /// <summary>
        /// Applies a sequence of methods to a decorator, appending a new line after applying a method.
        /// </summary>
        /// <param name="decorator">The decorator to apply a method to.</param>
        /// <param name="actions">The methods to apply to the decorator.</param>
        /// <returns>A reference to the decorator.</returns>
        public static TSelf operator %(OperatorsDecoratorBase<TMacro, TSelf> decorator, IEnumerable<Action<OperatorsDecoratorBase<TMacro, TSelf>>> actions)
        {
            foreach(var a in actions)
            {
                a.Invoke(decorator);
                _ = decorator.AppendLine();
            }

            return decorator.GetSelf();
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.Queue.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.Queue7ffb7270_638f_465d_b12d_cc0b814eb4fd.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;
using System.Text;

partial class ExpandingMacroStringBuilder
{
    /// <summary>
    /// Represents a queue of values and macros. _macros may be replaced at a later time.
    /// </summary>
    /// <typeparam name="TValue">The type of value to enqueue.</typeparam>
    /// <typeparam name="TMacro">The type of macro to enqueue.</typeparam>
    internal sealed partial class Queue<TValue, TMacro>
    {
        private Queue(Dictionary<TMacro, Stack<Queue<TValue, TMacro>.Node<TMacro>>> macros) => _macros = macros;
        public Queue() : this([]) { }

        private readonly Dictionary<TMacro, Stack<Node<TMacro>>> _macros;
        private Node? _first;
        private Node? _last;

        /// <summary>
        /// Gets a value indicating whether the queue contains any macros.
        /// </summary>
        public Boolean ContainsMacros => _macros.Any(static kvp => kvp.Value.Count > 0);
        public IReadOnlyList<TMacro> GetMacros() => _macros.SelectMany(static kvp => kvp.Value).Select(static n => n.Value).ToList();

        /// <summary>
        /// Gets an enumeration of distinct macros that have yet to be expanded.
        /// </summary>
        /// <returns>The distinct macros that have yet to be expanded.</returns>
        public IEnumerable<TMacro> UnexpandedMacros() => _macros.Where(s => s.Value.Count > 0).Select(kvp => kvp.Key);
        /// <summary>
        /// Adds a value to the end of the queue.
        /// </summary>
        /// <param name="value">The value to enqueue.</param>
        public Queue<TValue, TMacro> EnqueueValue(TValue value)
        {
            var node = Node<TValue>.Rent(value);
            Enqueue(node);
            return this;
        }
        /// <summary>
        /// Adds a macro to the end of the queue.
        /// </summary>
        /// <param name="macro">The macro to enqueue.</param>
        public Queue<TValue, TMacro> EnqueueMacro(TMacro macro)
        {
            var node = Node<TMacro>.Rent(macro);
            GetMacroNodes(macro).Push(node);
            Enqueue(node);
            return this;
        }
        /// <summary>
        /// Dequeues all sequential values from the end of the queue.
        /// </summary>
        /// <returns>The sequential values at the end of the queue.</returns>
        public IEnumerable<TValue> DequeueValues()
        {
            while(_first is Node<TValue> valueNode)
            {
                if(_last == _first)
                {
                    _last = valueNode.Next;
                }

                _first = valueNode.Next;
                var value = valueNode.Value;
                RemoveNode(valueNode);

                yield return value;
            }
        }
        /// <summary>
        /// Replaces all occurences of a macro with the replacement queue provided.
        /// </summary>
        /// <param name="macro">The macro to replace.</param>
        /// <param name="configureExpansionQueue">The action using which to configure the queue of items to replace occurences of the macro with.</param>
        public Queue<TValue, TMacro> Expand(TMacro macro, Action<Queue<TValue, TMacro>> configureExpansionQueue)
        {
            var nodes = GetMacroNodes(macro);
            if(nodes.Count == 0)
            {
                return this;
            }

            var replacementQueue = new Queue<TValue, TMacro>();
            configureExpansionQueue.Invoke(replacementQueue);

            if(replacementQueue._first == null)
            {
                RemoveMacros(nodes);
            } else
            {
                ReplaceMacros(replacementQueue, nodes);
            }

            return this;
        }

        private void Enqueue(Node? node)
        {
            if(_first == null)
            {
                _first = node;
            } else if(_last != null)
            {
                _last.Next = node;
                if(node != null)
                {
                    node.Previous = _last;
                }
            }

            _last = node;
        }
        private Stack<Node<TMacro>> GetMacroNodes(TMacro macro)
        {
            if(!_macros.TryGetValue(macro, out var nodes))
            {
                nodes = [];
                _macros.Add(macro, nodes);
            }

            return nodes;
        }
        private void ReplaceMacros(Queue<TValue, TMacro> replacementQueue, Stack<Node<TMacro>> nodes)
        {
            while(nodes.Count > 0)
            {
                var node = nodes.Pop();
                node.Replace(replacementQueue._first, replacementQueue._last);

                if(node == _first)
                {
                    _first = replacementQueue._first;
                }

                if(node == _last)
                {
                    _last = replacementQueue._last;
                }

                foreach(var kvp in replacementQueue._macros)
                {
                    while(kvp.Value.Count > 0)
                    {
                        GetMacroNodes(kvp.Key).Push(kvp.Value.Pop());
                    }
                }

                Node<TMacro>.Return(node);

                if(nodes.Count > 0)
                {
                    replacementQueue = replacementQueue.Clone();
                }
            }
        }
        private void RemoveMacros(Stack<Node<TMacro>> nodes)
        {
            while(nodes.Count > 0)
                RemoveNode(nodes.Pop());
        }
        private void RemoveNode<T>(Node<T> node)
        {
            RemoveFirstOrLast(node);
            node.RemoveSelf();
            Node<T>.Return(node);
        }
        private void RemoveFirstOrLast(Node node)
        {
            if(node == _first)
            {
                _first = null;
                _first = node.Next;
            }

            if(node == _last)
            {
                _last = null;
            }
        }
        private IEnumerable<Node> GetNodes()
        {
            var node = _first;
            while(node != null)
            {
                yield return node;

                node = node.Next;
            }
        }
        /// <inheritdoc/>
        public override String ToString() => GetNodes().Aggregate(new StringBuilder(), static (b, s) => b.Append(s)).ToString();
        internal Queue<TValue, TMacro> Clone()
        {
            var result = new Queue<TValue, TMacro>(new(_macros));
            var firstClone = _first?.Clone();
            result.Enqueue(firstClone);

            return result;
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ExpandingMacroStringBuilder.Queue.Node.cs";
#endif
c.AddSource(
    "ExpandingMacroStringBuilder.Queue.Node3fc7f2eb_052b_42c8_bf2b_604a6b32d525.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

partial class ExpandingMacroStringBuilder
{
    sealed partial class Queue<TValue, TMacro>
    {
        sealed class Node<T> : Node
        {
            private Node(T value) => _value = value;

            public T Value
            {
                get
                {
                    ValidateRented();
                    return _value!;
                }
                private set
                {
                    ValidateRented();
                    _value = value;
                }
            }

            private static readonly ConcurrentBag<Node<T>> _pool = [];
            private T? _value;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static Node<T> Rent(T value)
            {
                if(_pool.TryTake(out var result))
                {
                    result.SetRented();
                    result.Value = value;
                } else
                {
                    result = new Node<T>(value);
                    result.SetRented();
                }

                return result;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Return(Node<T> node)
            {
                node._value = default;
                node.Next = default;
                node.Previous = default;
                node.SetReturned();
                _pool.Add(node);
            }

            public override String ToString() => base.ToString().Replace("[ ]", $"[{(IsRented ? $"\"{Value}\"" : "_")}]");
            protected override Node CreateClone()
            {
                var result = Rent(Value);
                result.Previous = Previous?.Clone();
                result.Next = Next?.Clone();

                return result;
            }
        }
        abstract class Node
        {
            private Node? _previous;
            private Node? _next;

            public Node? Next
            {
                get
                {
                    ValidateRented();
                    return _next;
                }

                set
                {
                    ValidateRented();
                    _next = value;
                }
            }
            public Node? Previous
            {
                get
                {
                    ValidateRented();
                    return _previous;
                }

                set
                {
                    ValidateRented();
                    _previous = value;
                }
            }

            private Boolean _cloning;

            private const Int32 _rentedState = 1;
            private const Int32 _returnedState = 0;
            private Int32 _isRented = _returnedState;

            protected Boolean IsRented => _isRented == _rentedState;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void ValidateRented()
            {
                if(_isRented == _returnedState)
                {
                    throw new InvalidOperationException("Unable to access returned node.");
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void SetRented()
            {
                if(Interlocked.Exchange(ref _isRented, _rentedState) == _rentedState)
                {
                    throw new InvalidOperationException("Unable to rent node multiple times.");
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            protected void SetReturned()
            {
                if(Interlocked.Exchange(ref _isRented, _returnedState) == _returnedState)
                {
                    throw new InvalidOperationException("Unable to return node multiple times.");
                }
            }

            public void RemoveSelf()
            {
                if(Previous != null)
                    Previous.Next = Next;

                if(Next != null)
                    Next.Previous = Previous;
            }
            public void Replace(Node? first, Node? last)
            {
                if(Previous != null)
                    Previous.Next = first;
                if(first != null)
                    first.Previous = Previous;

                if(Next != null)
                    Next.Previous = last;
                if(last != null)
                    last.Next = Next;

                Previous = null;
                Next = null;
            }

            public override String ToString() => $"{(_previous != null ? "<" : String.Empty)}[ ]{(_next != null ? ">" : String.Empty)}";
            protected abstract Node CreateClone();
            internal Node Clone()
            {
                if(_cloning)
                {
                    return this;
                }

                _cloning = true;
                var result = CreateClone();
                _cloning = false;

                return result;
            }
        }
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\GeneratorContext.cs";
#endif
c.AddSource(
    "GeneratorContexte942fb3b_009f_4b53_8901_ee0918f37b08.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

/// <summary>
/// Contains factory methods for generator contexts.
/// </summary>
static partial class GeneratorContext
{
    /// <summary>
    /// Creates a new generator context.
    /// </summary>
    /// <param name="model">The model based on which to generate source code and diagnostics.</param>
    /// <param name="configureSourceTextBuilder">
    /// The optional configuration to apply to the underlying source 
    /// text builder after its instantiation.
    /// </param>
    /// <param name="configureDiagnosticsAccumulator">
    /// The optional configuration to apply to the underlying diagnostics
    /// accumulator after its instantiation.
    /// </param>
    /// <returns>The new generator context.</returns>
    public static IGeneratorContext<TMacro, TModel> Create<TMacro, TModel>(
        TModel model,
        Func<IExpandingMacroStringBuilder<TMacro>, IExpandingMacroStringBuilder<TMacro>>? configureSourceTextBuilder = null,
        Func<IDiagnosticsAccumulator<TModel>, IDiagnosticsAccumulator<TModel>>? configureDiagnosticsAccumulator = null)
    {
        var diagnosticsAccumulator = DiagnosticsAccumulator.Create(model);
        if(configureDiagnosticsAccumulator != null)
        {
            diagnosticsAccumulator = configureDiagnosticsAccumulator.Invoke(diagnosticsAccumulator);
        }

        var builder = ExpandingMacroStringBuilder.Create<TMacro>()
            .InterceptErrors(diagnosticsAccumulator);
        if(configureSourceTextBuilder != null)
        {
            builder = configureSourceTextBuilder.Invoke(builder);
        }

        var result = new Impl<TMacro, TModel>(
            builder,
            diagnosticsAccumulator,
            model);

        return result;
    }

    public static readonly DiagnosticDescriptor BuildErrorDiagnosticDescriptor =
        new(
            "RCUL0001",
            "Failure While Building Source",
            "An unexpected error occured while building source text: {0}",
            "Source Generator",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\GeneratorContext.Impl.cs";
#endif
c.AddSource(
    "GeneratorContext.Impl635ba9f9_0acd_4c14_aaea_fdd3ddb50c9b.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;
using System.Collections.Generic;
using System.Net.Http.Headers;

partial class GeneratorContext
{
    internal sealed class Impl<TMacro, TModel>(
    IExpandingMacroStringBuilder<TMacro> builder,
    IDiagnosticsAccumulator<TModel> diagnostics,
    TModel model) :
        IEquatable<Impl<TMacro, TModel>?>, IGeneratorContext<TMacro, TModel>
    {
        /// <summary>
        /// The underlying expanding macro string builder.
        /// </summary>
        private IExpandingMacroStringBuilder<TMacro> _sourceText = builder;
        /// <summary>
        /// The underlying diagnostics accumulator.
        /// </summary>
        private IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;
        /// <inheritdoc/>
        public TModel Model { get; } = model;

        public IGeneratorContext<TMacro, TModel> ApplyToSource(
            Func<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken, IExpandingMacroStringBuilder<TMacro>> build,
            CancellationToken cancellationToken)
        {
            _sourceText = build.Invoke(_sourceText, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToSource(
            Action<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken> build,
            CancellationToken cancellationToken)
        {
            build.Invoke(_sourceText, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(
            Func<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken, IDiagnosticsAccumulator<TModel>> diagnose,
            CancellationToken cancellationToken)
        {
            _diagnostics = diagnose.Invoke(_diagnostics, Model, cancellationToken);
            return this;
        }
        public IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(
            Action<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken> diagnose,
            CancellationToken cancellationToken)
        {
            diagnose.Invoke(_diagnostics, Model, cancellationToken);
            return this;
        }

        /// <inheritdoc/>
        public IGeneratorContext<TMacro, TModel> Receive<TProvider>(TProvider provider)
            where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>
        {
            _ = _diagnostics.Receive(provider);
            _ = _sourceText.Receive(provider);
            return this;
        }
        /// <inheritdoc/>
        public IGeneratorContext<TMacro, TModel> Receive<TProvider>()
            where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>, new() =>
            Receive(new TProvider());

        /// <inheritdoc/>
        public GeneratorContextBuildResult<TModel> BuildSource(CancellationToken cancellationToken)
        {
            String sourceText;
            var diagnostics = DiagnosticsAccumulator.Create(Model);
            _diagnostics.ReportDiagnostics(d => diagnostics.Add(d));

            try
            {
                sourceText = _sourceText.Build(cancellationToken);
            } catch(Exception ex)
            {
                _ = _diagnostics.Add(
                    Diagnostic.Create(
                        BuildErrorDiagnosticDescriptor,
                        Location.None,
                        ex));
                sourceText = String.Empty;
            }

            var result = new GeneratorContextBuildResult<TModel>(sourceText, diagnostics);

            return result;
        }

        /// <inheritdoc/>
        public override Boolean Equals(Object? obj) => Equals(obj as Impl<TMacro, TModel>);
        /// <inheritdoc/>
        public Boolean Equals(Impl<TMacro, TModel>? other) => other is not null && EqualityComparer<TModel>.Default.Equals(Model, other.Model);
        /// <inheritdoc/>
        public override Int32 GetHashCode() => -623947254 + EqualityComparer<TModel>.Default.GetHashCode(Model);
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\GeneratorContextBuildResult.cs";
#endif
c.AddSource(
    "GeneratorContextBuildResult5b4c7640_d95a_4e49_b875_ca8b686d091c.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.VisualBasic.Syntax;

using System;
using System.Collections.Generic;

/// <summary>
/// Represents the result of building source text using a generator context.
/// </summary>
/// <typeparam name="TModel">The type of model used.</typeparam>
/// <param name="sourceText">The source text generated.</param>
/// <param name="diagnostics">The diagnostics accumulator used while generating the source text.</param>
readonly struct GeneratorContextBuildResult<TModel>(String sourceText, IDiagnosticsAccumulator<TModel> diagnostics) : IEquatable<GeneratorContextBuildResult<TModel>>
{
    public readonly String SourceText = sourceText;
    private readonly IDiagnosticsAccumulator<TModel> _diagnostics = diagnostics;

    public void AddToContext(SourceProductionContext context, String hintName)
    {
        _diagnostics.ReportDiagnostics(context.ReportDiagnostic);
        context.AddSource(hintName, SourceText);
    }

    public override Boolean Equals(Object? obj) => obj is GeneratorContextBuildResult<TModel> result && Equals(result);
    public Boolean Equals(GeneratorContextBuildResult<TModel> other) => SourceText == other.SourceText;
    public override Int32 GetHashCode() => -1893336041 + EqualityComparer<String>.Default.GetHashCode(SourceText);
    public GeneratorContextBuildResult<TModel> WithSourceText(String sourceText) => new(sourceText, _diagnostics);

    public static Boolean operator ==(GeneratorContextBuildResult<TModel> left, GeneratorContextBuildResult<TModel> right) => left.Equals(right);
    public static Boolean operator !=(GeneratorContextBuildResult<TModel> left, GeneratorContextBuildResult<TModel> right) => !(left == right);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\IDiagnosticProvider.cs";
#endif
c.AddSource(
    "IDiagnosticProvidera00a20e0_c1b5_4ebf_b436_58b25bbb3abf.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

/// <summary>
/// Reports model diagnostics to an accumulator.
/// </summary>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IDiagnosticProvider<TModel>
{
    /// <summary>
    /// Diagnoses a model.
    /// </summary>
    /// <param name="model">The model to diagnose.</param>
    /// <param name="accumulator">The accumulator to report diagnostics to.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    void Diagnose(TModel model, IDiagnosticsAccumulator<TModel> accumulator, CancellationToken cancellationToken = default);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\IDiagnosticsAccumulator.cs";
#endif
c.AddSource(
    "IDiagnosticsAccumulatorcdce92aa_4aad_4ca5_982c_371832c7ce5e.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

using System.Threading;

/// <summary>
/// Incrementally accumulates model diagnostics.
/// </summary>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IDiagnosticsAccumulator<TModel>
{
    /// <summary>
    /// Gets a value indicating whether the accumulator currently contains errors.
    /// </summary>
    Boolean ContainsErrors { get; }
    /// <summary>
    /// Adds a diagnostic to the accumulator.
    /// </summary>
    /// <param name="diagnostic">The diagnostic to add.</param>
    /// <returns>A reference to the accumulator, for chaining of further method calls.</returns>
    IDiagnosticsAccumulator<TModel> Add(Diagnostic diagnostic);
    /// <summary>
    /// Reports the accumulated diagnostics to a report handler.
    /// For instance, the handler could be the <see cref="SyntaxNodeAnalysisContext.ReportDiagnostic(Diagnostic)"/> method.
    /// </summary>
    /// <param name="report">The context action to invoke in order to report diagnostics.</param>
    void ReportDiagnostics(Action<Diagnostic> report);
    /// <summary>
    /// Receives a diagnostics provider for generating diagnostics on the model.
    /// </summary>
    /// <param name="provider">The provider to generate diagnostics with.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference tothe accumulator, for chaining of further method calls.</returns>
    IDiagnosticsAccumulator<TModel> Receive(IDiagnosticProvider<TModel> provider, CancellationToken cancellationToken = default);
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\IExpandingMacroStringBuilder.cs";
#endif
c.AddSource(
    "IExpandingMacroStringBuilder3c31b39f_9ab8_4a81_865d_a28c61d2455f.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

/// <summary>
/// Represents a builder for incrementally constructing strings based on values and macros.
/// Macros must be expanded into values and/or further macros. 
/// The builder may only build the final result once there are no more macros to expand.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
interface IExpandingMacroStringBuilder<TMacro>
{
    /// <summary>
    /// Builds the result string.
    /// </summary>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>The result string.</returns>
    String Build(CancellationToken cancellationToken = default);
    /// <summary>
    /// Appends a string value to the builder.
    /// </summary>
    /// <param name="value">The string value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Append(String value);
    /// <summary>
    /// Appends a string value to the builder.
    /// </summary>
    /// <param name="value">The character value to append.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Append(Char value);
    /// <summary>
    /// Appends a macro to the builder.
    /// </summary>
    /// <param name="macro">The macro to append.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> AppendMacro(TMacro macro, CancellationToken cancellationToken = default);
    /// <summary>
    /// Registers a expansion provider to the builder and potentially executes macro expansions.
    /// </summary>
    /// <param name="provider">The provider to register.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the builder, for chaining of further methods.</returns>
    IExpandingMacroStringBuilder<TMacro> Receive(IMacroExpansion<TMacro> provider, CancellationToken cancellationToken = default);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\IGeneratorContext.cs";
#endif
c.AddSource(
    "IGeneratorContext60dcf845_864c_4c81_b73d_49534a1df189.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

/// <summary>
/// Represents the generator context for incremental generators. 
/// Appending or substituting values to the underlying source text 
/// builder are intercepted and discarded if the underlying
/// diagnostics accumulator is currently reporting errors.
/// This means that the expanding macro string builder provided by context 
/// instances will essentially short circuit upon errors having been 
/// reported by the diagnostics accumulator.
/// </summary>
/// <typeparam name="TMacro">The type of macro to support.</typeparam>
/// <typeparam name="TModel">The type of model to diagnose.</typeparam>
interface IGeneratorContext<TMacro, TModel>
{
    /// <summary>
    /// Gets the model to incrementally build up.
    /// </summary>
    TModel Model { get; }

    /// <summary>
    /// Applies a modification to the diagnostics accumulator underlying the context.
    /// </summary>
    /// <param name="diagnose">The modification to apply to the underlying diagnostics accumulator.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(Action<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken> diagnose, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a transformation to the diagnostics accumulator underlying the context.
    /// </summary>
    /// <param name="diagnose">The transformation to apply to the underlying diagnostics accumulator.</param>
    /// <param name="cancellationToken">A token signalling the diagnosis should terminate.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToDiagnostics(Func<IDiagnosticsAccumulator<TModel>, TModel, CancellationToken, IDiagnosticsAccumulator<TModel>> diagnose, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a modification to the string builder underlying the context.
    /// </summary>
    /// <param name="build">The modification to apply to the underlying string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToSource(Action<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken> build, CancellationToken cancellationToken);
    /// <summary>
    /// Applies a transformation to the string builder underlying the context.
    /// </summary>
    /// <param name="build">The transformation to apply to the underlying string builder.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> ApplyToSource(Func<IExpandingMacroStringBuilder<TMacro>, TModel, CancellationToken, IExpandingMacroStringBuilder<TMacro>> build, CancellationToken cancellationToken);

    /// <summary>
    /// Receives a new expansion and diagnostics provider of the type provided, 
    /// to be received by both the underlying diagnostics accumulator, as well 
    /// as the underlying source text builder.
    /// </summary>
    /// <typeparam name="TProvider">The type of provider to receive.</typeparam>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> Receive<TProvider>() where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>, new();
    /// <summary>
    /// Receives a expansion and diagnostics provider, to be received by both 
    /// the underlying diagnostics accumulator, as well as the underlying 
    /// source text builder.
    /// </summary>
    /// <typeparam name="TProvider">The type of provider to receive.</typeparam>
    /// <param name="provider">The provider to receive.</param>
    /// <returns>A reference to the context, for chaining of further method calls.</returns>
    IGeneratorContext<TMacro, TModel> Receive<TProvider>(TProvider provider) where TProvider : IMacroExpansion<TMacro>, IDiagnosticProvider<TModel>;

    /// <summary>
    /// Builds the source text.
    /// </summary>
    /// <param name="cancellationToken">The cancellation token used to signal source text generation to cancel.</param>
    /// <returns>The built source code.</returns>
    GeneratorContextBuildResult<TModel> BuildSource(CancellationToken cancellationToken);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\IMacroExpansion.cs";
#endif
c.AddSource(
    "IMacroExpansionf9080047_149f_49e1_8d96_c554c5813950.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

/// <summary>
/// Expands macro instances into values and/or further macros.
/// </summary>
/// <typeparam name="TMacro">The type of macro to expand.</typeparam>
interface IMacroExpansion<TMacro>
{
    /// <summary>
    /// Gets the macro instance to expand.
    /// </summary>
    TMacro Macro { get; }
    /// <summary>
    /// Expands the macro into an expanding macro string builder.
    /// </summary>
    /// <param name="builder">The builder to expand the macro into.</param>
    /// <param name="cancellationToken">The cancellation token used to signal expansion to cancel.</param>
    void Expand(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ImmutableArrayCollectionEqualityComparer.cs";
#endif
c.AddSource(
    "ImmutableArrayCollectionEqualityComparer59caac8f_e0a6_4fad_87b0_f4d8a0deb40d.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System.Collections.Immutable;
sealed class ImmutableArrayCollectionEqualityComparer<T>(IEqualityComparer<T> elementComparer) : IEqualityComparer<ImmutableArray<T>>
{
    public static ImmutableArrayCollectionEqualityComparer<T> Default { get; } = new(EqualityComparer<T>.Default);
    private readonly IEqualityComparer<T> _elementComparer = elementComparer;

    public Boolean Equals(ImmutableArray<T> x, ImmutableArray<T> y)
    {
        if(x.Length != y.Length)
        {
            return false;
        }

        if(x.Length == 0)
        {
            return true;
        }

        for(var i = 0; i < x.Length; i++)
        {
            if(!_elementComparer.Equals(x[i], y[i]))
            {
                return false;
            }
        }

        return true;
    }
    public Int32 GetHashCode(ImmutableArray<T> obj)
    {
        var hashCode = 997021164;
        for(var i = 0; i < obj.Length; i++)
        {
            var element = obj[i];
            hashCode = hashCode * -1521134295 + _elementComparer.GetHashCode(element);
        }

        return hashCode;
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ImmutableDictionaryCollectionEqualityComparer.cs";
#endif
c.AddSource(
    "ImmutableDictionaryCollectionEqualityComparer16c9fdc9_32b9_486c_a0c3_c095ba6a2111.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;
using System.Collections.Immutable;

sealed class ImmutableDictionaryCollectionEqualityComparer<TKey, TValue> : IEqualityComparer<ImmutableDictionary<TKey, TValue>>
    where TKey : notnull
{
    private ImmutableDictionaryCollectionEqualityComparer() { }
    public static ImmutableDictionaryCollectionEqualityComparer<TKey, TValue> Instance { get; } = new();

    public Boolean Equals(ImmutableDictionary<TKey, TValue> x, ImmutableDictionary<TKey, TValue> y)
    {
        if(x.Count != y.Count)
        {
            return false;
        }

        if(x.Count == 0)
        {
            return true;
        }

        foreach(var key in x.Keys)
        {
            if(!y.ContainsKey(key))
            {
                return false;
            }
        }

        return true;
    }
    public Int32 GetHashCode(ImmutableDictionary<TKey, TValue> obj)
    {
        var hashCode = 997021164;
        foreach(var element in obj)
        {
            hashCode = hashCode * -1521134295 + obj.KeyComparer.GetHashCode(element.Key);
        }

        return hashCode;
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ImmutableHashSetCollectionEqualityComparer.cs";
#endif
c.AddSource(
    "ImmutableHashSetCollectionEqualityComparer498a7612_4d86_41e2_9823_e0f80eadad53.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;
using System.Collections.Immutable;

sealed class ImmutableHashSetCollectionEqualityComparer<T> : IEqualityComparer<ImmutableHashSet<T>>
{
    private ImmutableHashSetCollectionEqualityComparer() { }
    public static ImmutableHashSetCollectionEqualityComparer<T> Instance { get; } = new();

    public Boolean Equals(ImmutableHashSet<T> x, ImmutableHashSet<T> y)
    {
        if(x.Count != y.Count)
        {
            return false;
        }

        if(x.Count == 0)
        {
            return true;
        }

        foreach(var element in x)
        {
            if(!y.Contains(element))
            {
                return false;
            }
        }

        return true;
    }
    public Int32 GetHashCode(ImmutableHashSet<T> obj)
    {
        var hashCode = 997021164;
        foreach(var element in obj)
        {
            hashCode = hashCode * -1521134295 + obj.KeyComparer.GetHashCode(element);
        }

        return hashCode;
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\InfinitelyRecursingExpansionException.cs";
#endif
c.AddSource(
    "InfinitelyRecursingExpansionExceptiona980d740_1862_4471_aa9d_61ff6205bd8d.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

/// <summary>
/// Thrown if an infinite macro expansion is detected.
/// </summary>
/// <typeparam name="TMacro">The type of macro to be expanded into a sequence containing itself.</typeparam>
/// <param name="macro">The macro to be expanded into a sequence containing itself.</param>
sealed class InfinitelyRecursingExpansionException<TMacro>(TMacro macro)
    : Exception($"Detected infinitely recursing macro expansion while expanding '{macro}'. Make sure that macro expansions do not expand into themselves.")
{
    /// <summary>
    /// Gets the macro to be expanded into a sequence containing itself.
    /// </summary>
    public TMacro Macro { get; } = macro;
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\MacroExpansion.cs";
#endif
c.AddSource(
    "MacroExpansiond07938e5_cad6_4a1a_b0d4_293d72484bf4.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

/// <summary>
/// Provides a base class for types implementing <see cref="IMacroExpansion{TMacro}"/>.
/// </summary>
/// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
/// <param name="macro">The macro to expand using this provider.</param>
abstract class MacroExpansion<TMacro>(TMacro macro) : IMacroExpansion<TMacro>
{
    /// <inheritdoc/>
    public TMacro Macro { get; } = macro;
    /// <inheritdoc/>
    public abstract void Expand(
        IExpandingMacroStringBuilder<TMacro> builder,
        CancellationToken cancellationToken);
}
/// <summary>
/// Provides factory and extension methods for macro expansion providers.
/// </summary>
static partial class MacroExpansion
{
    /// <summary>
    /// Creates a new empty macro expansion for the macro provided.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide an empty expansion for.</typeparam>
    /// <param name="macro">The macro to expand using the provider created.</param>
    /// <returns>A new empty macro expansion.</returns>
    public static IMacroExpansion<TMacro> CreateEmpty<TMacro>(TMacro macro) => new Empty<TMacro>(macro);
    /// <summary>
    /// Creates a new macro expansion provider.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
    /// <param name="macro">The macro to expand using the provider created.</param>
    /// <param name="strategy">The strategy using which to supply an expansion to an expanding macro string builder.</param>
    /// <returns>A new expansion.</returns>
    public static IMacroExpansion<TMacro> Create<TMacro>(
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy) =>
        new Strategy<TMacro>(macro, strategy);
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\MacroExpansion.Empty.cs";
#endif
c.AddSource(
    "MacroExpansion.Emptyd804c1b5_7930_4cef_8540_a137abc2d49a.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;
static partial class MacroExpansion
{
    internal sealed class Empty<TMacro>(TMacro macro) : MacroExpansion<TMacro>(macro)
    {
        public override void Expand(IExpandingMacroStringBuilder<TMacro> builder, CancellationToken cancellationToken) { }
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\MacroExpansion.Strategy.cs";
#endif
c.AddSource(
    "MacroExpansion.Strategybda8778e_98f2_4cc6_ac80_7bed5d50b35c.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

partial class MacroExpansion
{
    /// <summary>
    /// Imlements a strategy-based expansion provider.
    /// </summary>
    /// <typeparam name="TMacro">The type of macro to provide expansions for.</typeparam>
    /// <param name="macro">The macro to replace.</param>
    /// <param name="strategy">The strategy to use when replacing the macro.</param>
    internal sealed class Strategy<TMacro>(
        TMacro macro,
        Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> strategy) :
        MacroExpansion<TMacro>(macro)
    {
        private readonly Action<IExpandingMacroStringBuilder<TMacro>, CancellationToken> _strategy = strategy;
        /// <inheritdoc/>
        public override void Expand(
            IExpandingMacroStringBuilder<TMacro> builder,
            CancellationToken cancellationToken) =>
            _strategy.Invoke(builder, cancellationToken);
    }
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\SymbolExtensions.cs";
#endif
c.AddSource(
    "SymbolExtensions05345adf_d41c_4c03_8ea9_be4a18754d49.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System;

static class SymbolExtensions
{
    /// <summary>
    /// Gets the legible, fully qualified name of a symbol; suitable for use in hint names.
    /// </summary>
    /// <param name="symbol">The symbol whose hint name to get.</param>
    /// <returns>The symbols hint name.</returns>
    public static String ToHintName(this ISymbol symbol)=>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
                    .WithMiscellaneousOptions(
                    /*
                        get rid of special types

                                10110
                        NAND 00100
                            => 10010

                                10110
                            &! 00100
                            => 10010

                                00100
                            ^ 11111
                            => 11011

                                10110
                            & 11011
                            => 10010
                    */
                    SymbolDisplayFormat.FullyQualifiedFormat.MiscellaneousOptions &
                    (SymbolDisplayMiscellaneousOptions.UseSpecialTypes ^ (SymbolDisplayMiscellaneousOptions)Int32.MaxValue))
                    .WithGenericsOptions(SymbolDisplayGenericsOptions.IncludeTypeParameters))
                    .Replace("<", "_of_")
                    .Replace('>', '_')
                    .Replace(",", "_and_")
                    .Replace(" ", String.Empty)
                    .Replace('.', '_')
                    .Replace("::", "_")
                    .TrimEnd('_');
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\UnexpandedMacrosException.cs";
#endif
c.AddSource(
    "UnexpandedMacrosException57bae1d8_7696_4f2b_97da_bc461e514dd6.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using System;

/// <summary>
/// Thrown if <see cref="IExpandingMacroStringBuilder{TMacro}.Build(CancellationToken)"/> has been called but there are unexpanded macros present in the builder.
/// </summary>
/// <typeparam name="TMacro">The type of unexpanded macro.</typeparam>
/// <param name="macros">The list of unexpanded macros.</param>
sealed class UnexpandedMacrosException<TMacro>(IReadOnlyList<TMacro> macros) 
    : Exception($"Unable to build string; there is at least one unexpanded macro present in the builder. Make sure to provide expansions for all macros in use. Unexpanded macros: {String.Join(", ", macros)}")
{
    /// <summary>
    /// Gets the unexpanded macros.
    /// </summary>
    public IReadOnlyList<TMacro> Macros { get; } = macros;
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\ValueProviderExtensions.cs";
#endif
c.AddSource(
    "ValueProviderExtensions74967f12_939d_4ea6_b3eb_fd29379ca548.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library;

using Microsoft.CodeAnalysis;

using System.Collections.Immutable;

static class ValueProviderExtensions
{
    public static IncrementalValueProvider<ImmutableArray<T>> WithCollectionComparer<T>(this IncrementalValueProvider<ImmutableArray<T>> provider) =>
        provider.WithComparer(ImmutableArrayCollectionEqualityComparer<T>.Default);
    public static IncrementalValuesProvider<ImmutableArray<T>> WithCollectionComparer<T>(this IncrementalValuesProvider<ImmutableArray<T>> provider) =>
        provider.WithComparer(ImmutableArrayCollectionEqualityComparer<T>.Default);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\AttributeConstructorArgumentModel.cs";
#endif
c.AddSource(
    "AttributeConstructorArgumentModeld51464c3_411c_41af_a2e9_a23b48dc7ad2.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;
readonly record struct AttributeConstructorArgumentModel(String Name, String Value) :
    IIndentedStringBuilderAppendable
{
    public void AppendTo(IndentedStringBuilder builder) => builder.Append(Name).Append(": ").Append(Value);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\AttributePropertyArgumentModel.cs";
#endif
c.AddSource(
    "AttributePropertyArgumentModela7f82720_59ad_4f0d_95e9_db41f17b82df.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;
using System.Threading;

readonly record struct AttributePropertyArgumentModel(String Name, String Value) : IIndentedStringBuilderAppendable
{
    public void AppendTo(IndentedStringBuilder builder) => builder.Append(Name).Append(" = ").Append(Value);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\AttributeSyntaxModel.cs";
#endif
c.AddSource(
    "AttributeSyntaxModelafd9bf8a_f27f_4b03_a5a9_bc3dc190c3ef.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using RhoMicro.CodeAnalysis.Library;

using System.Collections.Immutable;
readonly record struct AttributeSyntaxModel(
    String Namespace,
    String Name,
    ImmutableArray<AttributeConstructorArgumentModel> ConstructorArguments,
    ImmutableArray<AttributePropertyArgumentModel> PropertyArguments) :
    IIndentedStringBuilderAppendable
{
    public void AppendTo(IndentedStringBuilder builder)
    {
        _ = builder.OpenBracketsBlock()
            .Append(Namespace)
            .Append('.')
            .Append(Name)
            .OpenParensBlock()
            .AppendJoin(", ", ConstructorArguments);
        
        if(PropertyArguments.Length > 0 && ConstructorArguments.Length > 0)
            _ = builder.Append(", ");

        _ = builder.AppendJoin(", ", PropertyArguments)
            .CloseAllBlocks();
    }

    private static readonly ImmutableArrayCollectionEqualityComparer<AttributeConstructorArgumentModel> _ctorArgsComparer =
        ImmutableArrayCollectionEqualityComparer<AttributeConstructorArgumentModel>.Default;
    private static readonly ImmutableArrayCollectionEqualityComparer<AttributePropertyArgumentModel> _propArgsComparer =
        ImmutableArrayCollectionEqualityComparer<AttributePropertyArgumentModel>.Default;
    public Boolean Equals(AttributeSyntaxModel other) =>
        other.Namespace == Namespace &&
        other.Name == Name &&
        _ctorArgsComparer.Equals(other.ConstructorArguments, ConstructorArguments) &&
        _propArgsComparer.Equals(other.PropertyArguments, PropertyArguments);
    public override Int32 GetHashCode() =>
        (Namespace, Name, _ctorArgsComparer.GetHashCode(ConstructorArguments), _propArgsComparer.GetHashCode(PropertyArguments)).GetHashCode();
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\Block.cs";
#endif
c.AddSource(
    "Block005d0de5_0d94_426d_bbf7_664876f5a2b4.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

readonly record struct Block(
    StringOrChar OpeningDelimiter = default,
    StringOrChar ClosingDelimiter = default,
    Boolean PlaceDelimitersOnNewLine = false,
    StringOrChar? Indentation = null);

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\Blocks.cs";
#endif
c.AddSource(
    "Blocks8ef72fc8_99ff_4c66_91fd_effef2b4f45e.g.cs", 
$$$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{{{DateTimeOffset.Now}}}}
// </auto-generated>
{{{{path}}}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

static partial class Blocks
{
    public static Block Indent { get; } = new();
    public static Block Braces(StringOrChar newLine) => new($"{{{newLine}", $"}}{newLine}", PlaceDelimitersOnNewLine: true);
    public static Block Parens { get; } = new('(', ')', Indentation: StringOrChar.Empty);
    public static Block Brackets { get; } = new('[', ']', Indentation: StringOrChar.Empty);
    public static Block Angled { get; } = new('<', '>', Indentation: StringOrChar.Empty);
    public static Block Region(String name, StringOrChar newLine) => new($"#region {name}{newLine}", $"#endregion{newLine}", PlaceDelimitersOnNewLine: true, Indentation: StringOrChar.Empty);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\BlockScope.cs";
#endif
c.AddSource(
    "BlockScope8b0c1fc3_9776_4010_8b87_08c4bdae61ea.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;
readonly struct BlockScope(IndentedStringBuilder builder) : IDisposable
{
    private readonly IndentedStringBuilder _builder = builder;
    public void Dispose() => _builder.CloseBlock();
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\BlockScopeCollection.cs";
#endif
c.AddSource(
    "BlockScopeCollectiond6cbf7dd_846d_45d1_b630_8b9c107a7c2d.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

sealed class BlockScopeCollection : IDisposable
{
    private readonly List<BlockScope> _scopes = [];
    public void AddScope(BlockScope scope) => _scopes.Add(scope);
    public void Dispose()
    {
        foreach(var scope in _scopes)
            scope.Dispose();
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\CommentBlocks.cs";
#endif
c.AddSource(
    "CommentBlocks2d8d9a2b_d4ca_4bbb_b677_e6c7a22e3c90.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;
static partial class CommentBlocks
{
    public static Block Multiline { get; } = new("/*\n", "*/", PlaceDelimitersOnNewLine: true);
    public static Block SingleLine { get; } = new(
        $"// ",
        StringOrChar.Empty,
        PlaceDelimitersOnNewLine: true,
        Indentation: StringOrChar.CommentSlashes);

    public static Block Summary { get; } = TopLevelDoc("summary");
    public static Block Returns { get; } = TopLevelDoc("returns");
    public static Block Remarks { get; } = TopLevelDoc("remarks");
    public static Block Param(String name) => TopLevelDoc("param", "name", name);
    public static Block TypeParam(String name) => TopLevelDoc("typeparam", "name", name);
    public static Block TopLevelDoc(String name) => new(
        $"/// <{name}>\n",
        $"/// </{name}>\n",
        PlaceDelimitersOnNewLine: true,
        Indentation: StringOrChar.DocCommentSlashes);
    public static Block TopLevelDoc(String name, String attributeName, String attributeValue)
    {
        var block = TopLevelDoc(name);
        var resut = block with
        {
            OpeningDelimiter = $"/// <{name} {attributeName}=\"{attributeValue}\">\n"
        };

        return resut;
    }

    public static Block Item { get; } = Doc("item");
    public static Block Term { get; } = Doc("item");
    public static Block Description { get; } = Doc("description");
    public static Block List(String type) => Doc("list", "type", type);
    public static Block Paragraph { get; } = Doc("para");
    public static Block Code { get; } = Doc("c");
    public static Block Doc(String name) => new(
        $"<{name}>\n",
        $"</{name}>\n",
        PlaceDelimitersOnNewLine: true,
        Indentation: StringOrChar.Empty);
    public static Block Doc(String name, String attributeName, String attributeValue) =>
        Doc(name) with
        {
            OpeningDelimiter = $"<{name} {attributeName}=\"{attributeValue}\">\n"
        };
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\CommentBuilder.cs";
#endif
c.AddSource(
    "CommentBuilderb3699aaf_c9ac_44f1_9168_0cd1ca9290b2.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

partial record CommentBuilder(IndentedStringBuilder Builder)
{
    #region Open Block
    public IndentedStringBuilder OpenSummary() =>
        Builder.OpenBlock(CommentBlocks.Summary);
    public IndentedStringBuilder OpenReturns() =>
        Builder.OpenBlock(CommentBlocks.Returns);
    public IndentedStringBuilder OpenRemarks() =>
        Builder.OpenBlock(CommentBlocks.Remarks);
    public IndentedStringBuilder OpenParam(String name) =>
        Builder.OpenBlock(CommentBlocks.Param(name));
    public IndentedStringBuilder OpenTypeParam(String name) =>
        Builder.OpenBlock(CommentBlocks.TypeParam(name));

    public IndentedStringBuilder OpenList(String type) =>
        Builder.OpenBlock(CommentBlocks.List(type));
    public IndentedStringBuilder OpenItem() =>
        Builder.OpenBlock(CommentBlocks.Item);
    public IndentedStringBuilder OpenTerm() =>
        Builder.OpenBlock(CommentBlocks.Term);
    public IndentedStringBuilder OpenDescription() =>
        Builder.OpenBlock(CommentBlocks.Description);

    public IndentedStringBuilder OpenParagraph() =>
        Builder.OpenBlock(CommentBlocks.Paragraph);
    public IndentedStringBuilder OpenCode() =>
        Builder.OpenBlock(CommentBlocks.Code);

    public IndentedStringBuilder OpenDocBlock(String name) =>
        Builder.OpenBlock(CommentBlocks.Doc(name));
    public IndentedStringBuilder OpenDocBlock(String name, String attributeName, String attributeValue) =>
        Builder.OpenBlock(CommentBlocks.Doc(name, attributeName, attributeValue));
    public IndentedStringBuilder OpenSingleLineBlock() =>
        Builder.OpenBlock(CommentBlocks.SingleLine);
    public IndentedStringBuilder OpenMultilineBlock() =>
        Builder.OpenBlock(CommentBlocks.Multiline);
    #endregion
    #region Open Block Scope
    public BlockScope OpenSingleLineBlockScope() => new(OpenSingleLineBlock());
    public BlockScope OpenMultilineBlockScope() => new(OpenMultilineBlock());
    public BlockScope OpenDocBlockScope(String name) => new(OpenDocBlock(name));
    public BlockScope OpenDocBlockScope(String name, String attributeName, String attributeValue) =>
        new(OpenDocBlock(name, attributeName, attributeValue));
    #endregion
    #region Self Closing
    public IndentedStringBuilder SeeRef(String name) =>
        Builder.Append("<see cref=\"").Append(name).Append("\"/>");
    public IndentedStringBuilder Langword(String name) =>
        Builder.Append("<see langword=\"").Append(name).Append("\"/>");
    public IndentedStringBuilder InheritDoc(String name, Boolean topLevel = true)
    {
        if(topLevel)
            _ = Builder.Append("/// ");

        _ = Builder.Append("<inheritdoc cref=\"").Append(name).Append("\"/>");

        if(topLevel)
            _ = Builder.AppendLine();

        return Builder;
    }
    public IndentedStringBuilder InheritDoc(Boolean topLevel = true)
    {
        if(topLevel)
            _ = Builder.Append("/// ");

        _ = Builder.Append("<inheritdoc/>");

        if(topLevel)
            _ = Builder.AppendLine();

        return Builder;
    }
    public IndentedStringBuilder TypeParamRef(String name) =>
        Builder.Append("<typeparamref name=\"").Append(name).Append("\"/>");
    public IndentedStringBuilder ParamRef(String name) =>
        Builder.Append("<paramref name=\"").Append(name).Append("\"/>");
    public IndentedStringBuilder InternalUse(String name) =>
        Builder.Comment.OpenRemarks()
        .Append("This member is not intended for use by user code inside of or any code outside of ").Comment.SeeRef(name).Append('.')
        .CloseBlock();
    #endregion
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\ContainingTypeModel.cs";
#endif
c.AddSource(
    "ContainingTypeModelc93097cd_7dec_42d3_82ef_c3a5d506afdf.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System.Collections.Immutable;

readonly record struct ContainingTypeModel(
    String Visibility,
    String TypeModifier,
    String Name,
    ImmutableArray<String> TypeParameters) :
    IIndentedStringBuilderAppendable
{
    public static ContainingTypeModel Create(INamedTypeSymbol symbol) =>
        new(SyntaxFacts.GetText(symbol.DeclaredAccessibility),
            Utils.GetTypeModifiers(symbol),
            symbol.Name,
            symbol.TypeParameters.Select(p => p.Name).ToImmutableArray());

    public void AppendTo(IndentedStringBuilder builder)
    {
        _ = builder.Append(Visibility)
            .Append(' ')
            .Append(TypeModifier)
            .Append(' ')
            .Append(Name);

        if(TypeParameters.Length > 0)
            _ = builder.OpenAngledBlock().AppendJoin(", ", TypeParameters).CloseBlock();
    }

    public Boolean Equals(ContainingTypeModel other) =>
        other.Visibility == Visibility &&
        other.TypeModifier == TypeModifier &&
        other.Name == Name &&
        other.TypeParameters.Length == TypeParameters.Length;
    public override Int32 GetHashCode() =>
        (Visibility, TypeModifier, Name, TypeParameters.Length).GetHashCode();
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IIndentedStringBuilderAppendable.cs";
#endif
c.AddSource(
    "IIndentedStringBuilderAppendable8e243b42_e19b_498b_8829_a21cfa6a7b0c.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

interface IIndentedStringBuilderAppendable
{
    public void AppendTo(IndentedStringBuilder builder);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IndentedStringBuilder.cs";
#endif
c.AddSource(
    "IndentedStringBuilder275cfcfd_5a03_4fa3_be44_22e0ea041007.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text;

partial class IndentedStringBuilder : IEquatable<IndentedStringBuilder?>
{
    public IndentedStringBuilder(IndentedStringBuilderOptions options)
    {
        Options = options;

        if(Options.PrependMarkerComment)
        {
            _ = _builder.Append("// <auto-generated>").Append(options.NewLine);

            if(!String.IsNullOrWhiteSpace(Options.GeneratorName))
            {
                _ = _builder.Append("// This file was last generated by ")
                    .Append(Options.GeneratorName)
                    .Append(" at ")
                    .Append(DateTimeOffset.Now.ToString()).Append(options.NewLine);
            }

            _ = _builder
                .Append("// The tool used to generate this code may be subject to license terms;").Append(options.NewLine)
                .Append("// this generated code is however not subject to those terms, instead it is").Append(options.NewLine)
                .Append("// subject to the license (if any) applied to the containing project.").Append(options.NewLine)
                .Append("// </auto-generated>").Append(options.NewLine);
        }

        if(Options.PrependWarningDisablePragma)
            _ = _builder.Append("#pragma warning disable").Append(options.NewLine);

        if(Options.PrependNullableEnable)
            _ = _builder.Append("#nullable enable").Append(options.NewLine);

        Comment = new(this);
        Operators = new(this);
    }

    public IndentedStringBuilder() : this(IndentedStringBuilderOptions.Default)
    { }

    #region Fields & Properties
    public CommentBuilder Comment { get; }
    public OperatorsDecorator Operators { get; }
    public IndentedStringBuilderOptions Options { get; }
    private readonly StringBuilder _builder = new();
    private readonly Stack<Block> _blocks = new();
    private readonly Stack<StringOrChar> _indentations = new();
    private Block? LastBlock => _blocks.Count > 0 ? _blocks.Peek() : null;
    private Boolean LastWasNewLine
    {
        get
        {
            if(_builder.Length < Options.NewLine.Length)
                return false;

            for(var i = 1; i <= Options.NewLine.Length; i++)
            {
                if(_builder[^i] != Options.NewLine[^i])
                    return false;
            }

            return true;
        }
    }
    public Int32 OpenBlocks => _blocks.Count;
    #endregion
    #region Open Block
    public void OpenBlockCore(Block block)
    {
        var delimiter = block.OpeningDelimiter;

        if(block.PlaceDelimitersOnNewLine && !LastWasNewLine)
            AppendSingleLineCore();

        AppendCore(delimiter);

        _blocks.Push(block);

        var indentation = block.Indentation ?? Options.DefaultIndentation;
        _indentations.Push(indentation);
    }
    public IndentedStringBuilder OpenBlock(Block block)
    {
        OpenBlockCore(block);
        return this;
    }
    public IndentedStringBuilder OpenBracketsBlock() => OpenBlock(Blocks.Brackets);
    public IndentedStringBuilder OpenIndentBlock() => OpenBlock(Blocks.Indent);
    public IndentedStringBuilder OpenBracesBlock() => OpenBlock(Blocks.Braces(Options.NewLine));
    public IndentedStringBuilder OpenParensBlock() => OpenBlock(Blocks.Parens);
    public IndentedStringBuilder OpenAngledBlock() => OpenBlock(Blocks.Angled);
    public IndentedStringBuilder OpenRegionBlock(String name) => OpenBlock(Blocks.Region(name, Options.NewLine));
    #endregion
    #region Open Block Scope
    public BlockScope OpenBlockScope(Block block) => new(OpenBlock(block));
    public BlockScope OpenBracketsBlockScope() => new(OpenBracketsBlock());
    public BlockScope OpenIndentBlockScope() => new(OpenIndentBlock());
    public BlockScope OpenBracesBlockScope() => new(OpenBracesBlock());
    public BlockScope OpenParensBlockScope() => new(OpenParensBlock());
    public BlockScope OpenAngledBlockScope() => new(OpenAngledBlock());
    public BlockScope OpenRegionBlockScope(String name) => new(OpenRegionBlock(name));

    public IndentedStringBuilder OpenBlockScope(Block block, BlockScopeCollection scopes)
    {
        var scope = OpenBlockScope(block);
        scopes.AddScope(scope);
        return this;
        ;
    }
    public IndentedStringBuilder OpenBracketsBlockScope(BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Brackets, scopes);
    public IndentedStringBuilder OpenIndentBlockScope(BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Indent, scopes);
    public IndentedStringBuilder OpenBracesBlockScope(BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Braces(Options.NewLine), scopes);
    public IndentedStringBuilder OpenParensBlockScope(BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Parens, scopes);
    public IndentedStringBuilder OpenAngledBlockScope(BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Angled, scopes);
    public IndentedStringBuilder OpenRegionBlockScope(String name, BlockScopeCollection scopes) =>
        OpenBlockScope(Blocks.Region(name, Options.NewLine), scopes);
    #endregion
    #region Close Block
    public void CloseBlockCore()
    {
        if(!LastBlock.HasValue)
            return;

        DetentUnsafeCore();

        var block = LastBlock.Value;

        if(block.PlaceDelimitersOnNewLine)
            AppendSingleLineCore();

        AppendCore(block.ClosingDelimiter);
        _ = _blocks.Pop();
    }
    public void CloseAllBlocksCore()
    {
        while(_blocks.Count > 0)
        {
            CloseBlockCore();
        }
    }
    public IndentedStringBuilder CloseBlock()
    {
        CloseBlockCore();
        return this;
    }
    public IndentedStringBuilder CloseAllBlocks()
    {
        CloseAllBlocksCore();
        return this;
    }
    #endregion
    #region Indent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void IndentCore() => _indentations.Push(Options.DefaultIndentation);
    public IndentScope CreateIndentScope() => new(Indent());
    public IndentedStringBuilder Indent()
    {
        IndentCore();
        return this;
    }
    void ApplyIndentation()
    {
        if(!LastWasNewLine)
            return;

        foreach(var indentation in _indentations.Reverse())
        {
            ThrowIfCancellationRequested();

            _ = indentation.IsString ?
                _builder.Append((String)indentation) :
                _builder.Append((Char)indentation);
        }
    }
    #endregion
    #region Detent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void DetentUnsafeCore() => _ = _indentations.Pop();
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DetentCore()
    {
        if(_indentations.Count > 0)
        {
            if(!_indentations.Peek().IsWhitespace)
                throw new InvalidOperationException("Attempted to detent non-whitespace indentation. Use 'CloseBlock' or 'CloseAllBlocks' instead.");

            DetentUnsafeCore();
        }
    }
    public IndentedStringBuilder Detent()
    {
        DetentCore();
        return this;
    }
    #endregion
    #region Append String
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(String value)
    {
        ThrowIfCancellationRequested();

        _ = _builder.Append(value);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendCore(String value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public void Add(String value) => AppendCore(value);
    public IndentedStringBuilder Append(String value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params String[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<String> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<String> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Char
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(Char value)
    {
        ThrowIfCancellationRequested();

        _ = _builder.Append(value);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendCore(Char value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public void Add(Char value) => AppendCore(value);
    public IndentedStringBuilder Append(Char value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params Char[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<Char> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<Char> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append T
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation<T>(T value)
        where T : IIndentedStringBuilderAppendable
        => value?.AppendTo(this);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendCore<T>(T value)
        where T : IIndentedStringBuilderAppendable
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public void Add<T>(T value)
        where T : IIndentedStringBuilderAppendable
        => AppendCore(value);
    public IndentedStringBuilder Append<T>(T value)
        where T : IIndentedStringBuilderAppendable
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append<T>(params T[] values)
        where T : IIndentedStringBuilderAppendable
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(ImmutableArray<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Action
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(Action<IndentedStringBuilder> value)
        => value?.Invoke(this);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendCore(Action<IndentedStringBuilder> value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public void Add(Action<IndentedStringBuilder> value)
        => AppendCore(value);
    public IndentedStringBuilder Append(Action<IndentedStringBuilder> value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params Action<IndentedStringBuilder>[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<Action<IndentedStringBuilder>> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<Action<IndentedStringBuilder>> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Join
    public IndentedStringBuilder AppendJoin(IEnumerable<String> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<String> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }

    public IndentedStringBuilder AppendJoin(IEnumerable<Char> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<Char> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }

    public IndentedStringBuilder AppendJoin<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
        => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin<T>(StringOrChar separator, IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
        => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines<T>(StringOrChar separator, IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }

    public IndentedStringBuilder AppendJoin(IEnumerable<Action<IndentedStringBuilder>> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<Action<IndentedStringBuilder>> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<Action<IndentedStringBuilder>> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<Action<IndentedStringBuilder>> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    #endregion
    #region Append Line
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendLineCore()
    {
        ThrowIfCancellationRequested();

        _ = Options.NewLine.IsString ?
            _builder.Append((String)Options.NewLine) :
            _builder.Append((Char)Options.NewLine);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendSingleLineCore()
    {
        if(LastWasNewLine)
            return;

        AppendLineCore();
    }
    public IndentedStringBuilder AppendLine()
    {
        AppendLineCore();
        return this;
    }
    public IndentedStringBuilder AppendLine(String value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine(Char value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine(Action<IndentedStringBuilder> value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine<T>(T value)
        where T : IIndentedStringBuilderAppendable
        => Append(value).AppendLine();
    #endregion
    #region ToString & Equality
    public IndentedStringBuilder Clear()
    {
        _indentations.Clear();
        _blocks.Clear();
        _ = _builder.Clear();
        return this;
    }
    public override String ToString() => _builder.ToString();
    public override Boolean Equals(Object? obj) => Equals(obj as IndentedStringBuilder);
    public Boolean Equals(IndentedStringBuilder? other) =>
        other is not null &&
        CollectionEqualityComparer<StringOrChar>.Default.Equals(_indentations, other._indentations) &&
        CollectionEqualityComparer<Block>.Default.Equals(_blocks, other._blocks) &&
        EqualityComparer<StringBuilder>.Default.Equals(_builder, other._builder);
    public override Int32 GetHashCode() =>
        (
            _builder,
            CollectionEqualityComparer<StringOrChar>.Default.GetHashCode(_indentations),
            CollectionEqualityComparer<Block>.Default.GetHashCode(_blocks)
        ).GetHashCode();
    #endregion
    #region Cancellation
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfCancellationRequested() => Options.AmbientCancellationToken.ThrowIfCancellationRequested();
    #endregion
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IndentedStringBuilder.OperatorsDecorator.cs";
#endif
c.AddSource(
    "IndentedStringBuilder.OperatorsDecorator5dc84eca_dc1f_452f_8fa0_fdf1bd2077c1.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

partial class IndentedStringBuilder
{
    public record OperatorsDecorator(IndentedStringBuilder Builder)
    {
        public static OperatorsDecorator operator +(OperatorsDecorator operators, String value)
        {
            operators.Builder.AppendCore(value);
            return operators;
        }
        public static OperatorsDecorator operator +(OperatorsDecorator operators, Char value)
        {
            operators.Builder.AppendCore(value);
            return operators;
        }
        public static OperatorsDecorator operator +(OperatorsDecorator operators, IIndentedStringBuilderAppendable value)
        {
            operators.Builder.AppendCore(value);
            return operators;
        }
        public override String ToString() => Builder.ToString();
        public virtual Boolean Equals(OperatorsDecorator? other) =>
            other != null &&
            other.Builder.Equals(Builder);
        public override Int32 GetHashCode() => Builder.GetHashCode();
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IndentedStringBuilderAppendable.cs";
#endif
c.AddSource(
    "IndentedStringBuilderAppendable211fc860_685b_45cd_b889_a2150ceae000.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

sealed class IndentedStringBuilderAppendable(Action<IndentedStringBuilder> strategy) : IIndentedStringBuilderAppendable
{
    public void AppendTo(IndentedStringBuilder builder) => strategy.Invoke(builder);
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IndentedStringBuilderOptions.cs";
#endif
c.AddSource(
    "IndentedStringBuilderOptions3bfb6600_c122_4e5a_b702_5a9001216d30.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

partial record IndentedStringBuilderOptions
{
    public StringOrChar DefaultIndentation { get; init; } = StringOrChar.Tab;
    public StringOrChar NewLine { get; init; } = StringOrChar.NewLine;
    public String GeneratorName { get; init; } = String.Empty;
    public Boolean PrependMarkerComment { get; init; } = false;
    public Boolean PrependWarningDisablePragma { get; init; } = false;
    public Boolean PrependNullableEnable { get; init; } = false;
    public CancellationToken AmbientCancellationToken { get; init; } = CancellationToken.None;

    public static IndentedStringBuilderOptions GeneratedFile = new()
    {
        PrependMarkerComment = true,
        PrependWarningDisablePragma = true,
        PrependNullableEnable = true
    };
    public static IndentedStringBuilderOptions Default = new();
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\IndentScope.cs";
#endif
c.AddSource(
    "IndentScope50f575de_98a0_4b07_b44c_ec3d07771fef.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

readonly struct IndentScope(IndentedStringBuilder builder) : IDisposable
{
    private readonly IndentedStringBuilder _builder = builder;
    public void Dispose() => _builder.Detent();
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\ISourceModel.cs";
#endif
c.AddSource(
    "ISourceModel46f954da_957b_459a_a496_c8894041e498.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;
interface ISourceModel
{
    SourceModelResult GetSourceResult(CancellationToken cancellationToken);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\PartialClassModel.cs";
#endif
c.AddSource(
    "PartialClassModel753707b7_9b0d_45a6_add8_4c801d380a2e.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System.Collections.Immutable;

record PartialClassModel(
    String Namespace,
    ImmutableArray<ContainingTypeModel> ContainingTypes,
    ImmutableArray<AttributeSyntaxModel> Attributes,
    String Visibility,
    String TypeModifiers,
    String Name,
    ImmutableArray<StringOrChar> TypeParameters,
    ImmutableArray<String> ImplementedTypes) :
    IIndentedStringBuilderAppendable
{
    public PartialClassModel(
        String @namespace,
        ImmutableArray<ContainingTypeModel> containingTypes,
        String visibility,
        String typeModifiers,
        String name,
        ImmutableArray<StringOrChar> typeParameters)
        : this(
             @namespace,
             containingTypes,
             ImmutableArray.Create<AttributeSyntaxModel>(),
             visibility,
             typeModifiers,
             name,
             typeParameters,
             ImmutableArray.Create<String>())
    { }

    public static PartialClassModel Create(INamedTypeSymbol symbol)
    {
        var @namespace = symbol.ContainingNamespace.ToDisplayString(
                    SymbolDisplayFormat.FullyQualifiedFormat
                    .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
        var containingTypesBuilder = ImmutableArray.CreateBuilder<ContainingTypeModel>();
        appendContainingType(symbol.ContainingType);
        var containingTypes = containingTypesBuilder.ToImmutable();
        var visibility = SyntaxFacts.GetText(symbol.DeclaredAccessibility);
        var typeModifiers = Utils.GetTypeModifiers(symbol);
        var name = symbol.Name;
        ImmutableArray<StringOrChar> typeParameters;
        if(symbol.TypeParameters.Length > 0)
        {
            var typeParamsBuilder = ImmutableArray.CreateBuilder<StringOrChar>();
            for(var i = 0; i < symbol.TypeParameters.Length; i++)
            {
                var param = symbol.TypeParameters[i].Name;
                typeParamsBuilder.Add(param);
            }

            typeParameters = typeParamsBuilder.ToImmutable();
        } else
        {
            typeParameters = ImmutableArray.Create<StringOrChar>();
        }

        var result = new PartialClassModel(
            @namespace,
            containingTypes,
            visibility,
            typeModifiers,
            name,
            typeParameters);

        return result;

        void appendContainingType(INamedTypeSymbol? parent)
        {
            if(parent == null)
                return;

            appendContainingType(parent.ContainingType);
            var model = ContainingTypeModel.Create(parent);
            containingTypesBuilder!.Add(model);
        }
    }

    public void AppendTo(IndentedStringBuilder builder)
    {
        _ = builder.Append("namespace ")
        .AppendLine(Namespace)
        .OpenBracesBlock();
        for(var i = 0; i < ContainingTypes.Length; i++)
        {
            _ = builder.Append(ContainingTypes[i]).OpenBracketsBlock();
        }

        if(!String.IsNullOrEmpty(Visibility))
        {
            _ = builder.Append(Visibility).Append(' ');
        }

        _ = builder.Append(TypeModifiers).Append(' ').Append(Name);
        if(TypeParameters.Length > 0)
        {
            _ = builder.OpenAngledBlock().AppendJoin(", ", TypeParameters).CloseBlock();
        }

        if(ImplementedTypes.Length > 0)
        {
            _ = builder.Append(": ")
                .AppendLine()
                .AppendJoinLines(',', ImplementedTypes);
        }

        _ = builder.OpenBracketsBlock();
    }

    public virtual Boolean Equals(PartialClassModel? other) =>
        other != null &&
        Namespace == other.Namespace &&
        Visibility == other.Visibility &&
        TypeModifiers == other.TypeModifiers &&
        Name == other.Name &&
        TypeParameters.Length == other.TypeParameters.Length &&
        ImmutableArrayCollectionEqualityComparer<ContainingTypeModel>.Default.Equals(ContainingTypes, other.ContainingTypes) &&
        ImmutableArrayCollectionEqualityComparer<AttributeSyntaxModel>.Default.Equals(Attributes, other.Attributes) &&
        ImmutableArrayCollectionEqualityComparer<String>.Default.Equals(ImplementedTypes, other.ImplementedTypes);
    public override Int32 GetHashCode() =>
        (Namespace,
         Visibility,
         TypeModifiers,
         Name,
         TypeParameters.Length.GetHashCode(),
         ImmutableArrayCollectionEqualityComparer<ContainingTypeModel>.Default.GetHashCode(ContainingTypes),
         ImmutableArrayCollectionEqualityComparer<AttributeSyntaxModel>.Default.GetHashCode(Attributes),
         ImmutableArrayCollectionEqualityComparer<String>.Default.GetHashCode(ImplementedTypes))
        .GetHashCode();
}
""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\SourceModelResult.cs";
#endif
c.AddSource(
    "SourceModelResultfccdbde7_524f_49a9_86b7_f1dff31bfe12.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using Microsoft.CodeAnalysis;

using System;
using System.Collections.Immutable;

readonly record struct SourceModelResult(String HintName, String SourceText, ImmutableArray<Diagnostic> Diagnostics)
{
    private static readonly ImmutableArray<Diagnostic> _emptyDiagnostics = ImmutableArray.Create<Diagnostic>();
    public static SourceModelResult Create(String hint, String sourceText)
    {
        var hintName = $"{hint}_{Guid.NewGuid().ToString().Replace('-', '_')}.g.cs";
        var result = new SourceModelResult(hintName, sourceText, _emptyDiagnostics);

        return result;
    }

    public void AddToContext(SourceProductionContext context)
    {
        context.AddSource(HintName, SourceText);
        for(var i = 0; i < Diagnostics.Length; i++)
        {
            context.ReportDiagnostic(Diagnostics[i]);
        }
    }
    public static void AddToContext(SourceProductionContext context, SourceModelResult result) => result.AddToContext(context);
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\StringOrChar.cs";
#endif
c.AddSource(
    "StringOrChard2078ed6_8d57_4eee_b1d1_58b00ad49f21.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using System.Threading;
using System;

readonly struct StringOrChar : IEquatable<StringOrChar>, IIndentedStringBuilderAppendable
{
    private readonly Char _charValue;
    private readonly String? _stringValue;
    private readonly Byte _isChar;

    public Boolean IsWhitespace => IsString ?
        String.IsNullOrWhiteSpace(_stringValue!) :
        Char.IsWhiteSpace(_charValue);

    public static StringOrChar Empty { get; } = String.Empty;
    public static StringOrChar NewLine { get; } = '\n';
    public static StringOrChar Comma { get; } = ',';
    public static StringOrChar Semicolon { get; } = ';';
    public static StringOrChar Period { get; } = '.';
    public static StringOrChar Tab { get; } = '\t';
    public static StringOrChar TwoSpaces { get; } = "  ";
    public static StringOrChar FourSpaces { get; } = "    ";
    public static StringOrChar DocCommentSlashes { get; } = "/// ";
    public static StringOrChar CommentSlashes { get; } = "// ";
    public Char this[Int32 index] => IsString ?
        _stringValue![index] :
        index == 0 ?
        _charValue :
        throw new IndexOutOfRangeException();
    public ReadOnlySpan<Char> Slice(Int32 start, Int32 length) => IsString ?
        _stringValue!.AsSpan(start, length) :
        start == 0 && length is 1 or 0 ?
        new ReadOnlySpan<Char>([_charValue]) :
        throw new IndexOutOfRangeException();
    public Int32 Length => IsString ? _stringValue!.Length : 1;
    public Boolean IsString => _isChar == 0;

    private StringOrChar(String stringValue) => _stringValue = stringValue;
    private StringOrChar(Char charValue)
    {
        _charValue = charValue;
        _isChar = 1;
    }

    public static implicit operator StringOrChar(String value) => new(value);
    public static explicit operator String(StringOrChar value) => value.IsString ?
        value._stringValue ?? String.Empty :
        throw new InvalidOperationException();

    public static implicit operator StringOrChar(Char value) => new(value);
    public static explicit operator Char(StringOrChar value) => value.IsString ?
        throw new InvalidOperationException() :
        value._charValue;

    public static Boolean operator ==(StringOrChar left, StringOrChar right) => left.Equals(right);
    public static Boolean operator !=(StringOrChar left, StringOrChar right) => !(left == right);

    public override String ToString() => IsString ?
        _stringValue ?? String.Empty :
        _charValue.ToString();
    public override Boolean Equals(Object? obj) =>
        obj is StringOrChar stringOrChar &&
        Equals(stringOrChar);
    public Boolean Equals(StringOrChar other) =>
        IsString == other.IsString &&
        IsString ?
        (String)this == (String)other :
        (Char)this == (Char)other;
    public override Int32 GetHashCode() =>
        IsString ?
        ((String)this).GetHashCode() :
        ((Char)this).GetHashCode();
    public void AppendTo(IndentedStringBuilder builder)
    {
        _ = IsString ?
        builder.Append(_stringValue ?? String.Empty) :
        builder.Append(_charValue);
    }
}

""");
#if DEBUG
path = @"// G:\Documents\Projects\PaulBraetz\RhoMicro.CodeAnalysis\UtilityGenerators.Library\Text\Utils.cs";
#endif
c.AddSource(
    "Utils1e46d20c_68f6_4554_8a0a_bc73edf417f6.g.cs", 
$$"""
// <auto-generated>
// This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
// </auto-generated>
{{path}}
#pragma warning disable
namespace RhoMicro.CodeAnalysis.Library.Text;

using Microsoft.CodeAnalysis;

static partial class Utils
{
    public static String GetTypeModifiers(INamedTypeSymbol symbol) =>
        symbol.IsRecord
            ? symbol.IsReferenceType
                ? symbol.IsSealed ? "sealed record" : "record"
                : symbol.IsReadOnly ? "readonly record struct" : "record struct"
            : symbol.IsReferenceType
                ? symbol.IsSealed ? "sealed class" : "class"
                : symbol.IsReadOnly
                            ? symbol.IsRefLikeType ? "readonly ref struct" : "readonly struct"
                            : symbol.IsRefLikeType ? "ref struct" : "struct";
}

""");
        });
    }
}