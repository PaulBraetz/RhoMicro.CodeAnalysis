namespace RhoMicro.CodeAnalysis.UtilityGenerators;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;

partial class LibraryGenerator
{
    const String _decoratorParamName = "decorator";
    static partial void InitializeStatic(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            static (n, t) => n is BinaryExpressionSyntax b and { Right: TupleExpressionSyntax } &&
                        (b.IsKind(SyntaxKind.MultiplyExpression) ||
                         b.IsKind(SyntaxKind.DivideExpression) ||
                         b.IsKind(SyntaxKind.ModuloExpression)),
            (c, t) =>
            {
                var semanticModel = c.SemanticModel;

                var expr = (BinaryExpressionSyntax)c.Node;
                if(!IsExprLeftBinaryBuilder(expr, semanticModel, t))
                {
                    return ImmutableArray.Create<(String, String)>();
                }

                var rhs = (expr.Right as TupleExpressionSyntax)!;
                var result = ArgInfos.CreateAll(semanticModel, rhs, t)
                    .Select(static i => (
                        i.GetArgumentTypes(),
                        i.GetArgumentsPart()))
                    .ToImmutableArray();

                return result;
            }).WithComparer(ImmutableArrayCollectionEqualityComparer<(String, String)>.Default)
            .SelectMany((i, t) => i)
            .Collect()
            .Select(static (v, t) => v.Distinct().ToList())
            .Select(static (values, t) =>
            {
                var hintName = $"ExpandingMacroStringBuilder.OperatorsDecorator.Operators.g.cs";
                var sourceTextBuilder = new StringBuilder($$"""
                    // <auto-generated>
                    // This file was last generated by the RhoMicro.CodeAnalysis.UtilityGeneratorsLibraryGenerator on {{DateTimeOffset.Now}}
                    // </auto-generated>
                    #pragma warning disable
                    namespace RhoMicro.CodeAnalysis.Library;
                    
                    partial class ExpandingMacroStringBuilder
                    {
                        partial class OperatorsDecorator<TMacro, TModel>
                        {
                    """);

                foreach(var (types, args) in values)
                {
                    _ = sourceTextBuilder.Append($$"""

                                /// <summary>
                                /// Applies a method to a decorator.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro, TModel> operator *(
                                    OperatorsDecorator<TMacro, TModel> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro, TModel>, {{types}}>, {{types}}) invocation)
                                {
                                    invocation.Item1.Invoke({{args}});
                                    return decorator.GetSelf();
                                }
                        
                                /// <summary>
                                /// Applies a method to a decorator, appending a new line before applying the method.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro, TModel> operator /(
                                    OperatorsDecorator<TMacro, TModel> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro, TModel>, {{types}}>, {{types}}) invocation)
                                {
                                    _ = decorator.AppendLine();
                                    invocation.Item1.Invoke({{args}});
                                    return decorator.GetSelf();
                                }
                        
                                /// <summary>
                                /// Applies a method to a decorator, appending a new line after applying the method.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro, TModel> operator %(
                                    OperatorsDecorator<TMacro, TModel> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro, TModel>, {{types}}>, {{types}}) invocation)
                                {
                                    invocation.Item1.Invoke({{args}});
                                    _ = decorator.AppendLine();
                                    return decorator.GetSelf();
                                }
                        """);
                }

                _ = sourceTextBuilder.Append("""

                        }
                        partial class OperatorsDecorator<TMacro>
                        {
                    """);

                foreach(var (types, args) in values)
                {
                    _ = sourceTextBuilder.Append($$"""

                                /// <summary>
                                /// Applies a method to a decorator.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro> operator *(
                                    OperatorsDecorator<TMacro> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro>, {{types}}>, {{types}}) invocation)
                                {
                                    invocation.Item1.Invoke({{args}});
                                    return decorator.GetSelf();
                                }
                        
                                /// <summary>
                                /// Applies a method to a decorator, appending a new line before applying the method.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro> operator /(
                                    OperatorsDecorator<TMacro> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro>, {{types}}>, {{types}}) invocation)
                                {
                                    _ = decorator.AppendLine();
                                    invocation.Item1.Invoke({{args}});
                                    return decorator.GetSelf();
                                }
                        
                                /// <summary>
                                /// Applies a method to a decorator, appending a new line after applying the method.
                                /// </summary>
                                /// <param name="decorator">The decorator to apply a method to.</param>
                                /// <param name="invocation">The method, including its second argument, to apply to the decorator.</param>
                                /// <returns>A reference to the decorator.</returns>
                                public static OperatorsDecorator<TMacro> operator %(
                                    OperatorsDecorator<TMacro> {{_decoratorParamName}},
                                    (global::System.Action<OperatorsDecorator<TMacro>, {{types}}>, {{types}}) invocation)
                                {
                                    invocation.Item1.Invoke({{args}});
                                    _ = decorator.AppendLine();
                                    return decorator.GetSelf();
                                }
                        """);
                }

                var sourceText = sourceTextBuilder
                    .AppendLine()
                    .AppendLine("\t}")
                    .AppendLine("}")
                    .ToString();

                return (hintName, sourceText);
            });

        context.RegisterSourceOutput(provider, static (c, t) => c.AddSource(t.hintName, t.sourceText));
    }

    static Boolean IsExprLeftBinaryBuilder(BinaryExpressionSyntax expr, SemanticModel semanticModel, CancellationToken cancellationToken)
    {
        var leftExprType = semanticModel.GetTypeInfo(expr.Left, cancellationToken: cancellationToken).Type;
        var result = IsBuilderType(leftExprType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) ||
                     (expr.Left.IsKind(SyntaxKind.MultiplyExpression) ||
                     expr.Left.IsKind(SyntaxKind.ModuloExpression) ||
                     expr.Left.IsKind(SyntaxKind.DivideExpression)) &&
                     IsExprLeftBinaryBuilder((BinaryExpressionSyntax)expr.Left, semanticModel, cancellationToken);

        return result;
    }

    static Boolean IsBuilderType(String? symbolName) => symbolName?
        .StartsWith("global::RhoMicro.CodeAnalysis.Library.ExpandingMacroStringBuilder.OperatorsDecorator")
        ?? false;
}
