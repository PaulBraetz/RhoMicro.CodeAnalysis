namespace RhoMicro.CodeAnalysis.UnionsGenerator.Tests;

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Basic.Reference.Assemblies;
using RhoMicro.CodeAnalysis.UnionsGenerator.Generators;

/// <summary>
/// Base class for tests verifying <see cref="UnionsGenerator"/> outputs.
/// </summary>
public abstract class GeneratorTest
{
    protected GeneratorTest() : this(NetStandard20.References.All.ToArray()) { }
    protected GeneratorTest(IEnumerable<MetadataReference> references) =>
        _references = [.. references];

    private readonly MetadataReference[] _references;

    //requiring >= C#11 due to file scoped modifiers
    private const LanguageVersion _targetLanguageVersion = LanguageVersion.CSharp11;
    private static readonly CSharpParseOptions _parseOptions =
        new(languageVersion: _targetLanguageVersion,
            documentationMode: DocumentationMode.Diagnose,
            kind: SourceCodeKind.Regular);
    /// <summary>
    /// Invokes an assertion on the union type implementation generated from a source.
    /// </summary>
    /// <param name="source"></param>
    /// <param name="assertion"></param>
    /// <param name="unionTypeName"></param>
    public void TestUnionType(String source, Action<INamedTypeSymbol> assertion, String? unionTypeName = null)
    {
        _ = assertion ?? throw new ArgumentNullException(nameof(assertion));

        Compilation compilation = CreateCompilation(source, out var sourceTree);
        _ = RunGenerator(ref compilation);
        var declaration = sourceTree.GetRoot()
            .DescendantNodesAndSelf()
            .OfType<TypeDeclarationSyntax>()
            .SingleOrDefault(d => unionTypeName == null || d.Identifier.Text == unionTypeName);
        Assert.NotNull(declaration);
        var symbol = compilation.GetSemanticModel(sourceTree)
            .GetDeclaredSymbol(declaration);
        Assert.NotNull(symbol);
        assertion.Invoke(symbol!);
    }
    /// <summary>
    /// Invokes an assertion on the result of running the generator once on a source.
    /// </summary>
    /// <param name="source"></param>
    /// <param name="assertion"></param>
    public void TestDriverResult(String source, Action<GeneratorDriverRunResult> assertion)
    {
        _ = assertion ?? throw new ArgumentNullException(nameof(assertion));

        Compilation compilation = CreateCompilation(source, out var _);
        var result = RunGenerator(ref compilation);
        assertion.Invoke(result);
    }

    private GeneratorDriverRunResult RunGenerator(ref Compilation compilation)
    {
        var generator = new UnionsGenerator();

        var driver = CSharpGeneratorDriver.Create(generator)
            .WithUpdatedParseOptions(_parseOptions);

        // Run the generation pass
        // (Note: the generator driver itself is immutable, and all calls return an updated version of the driver that you should use for subsequent calls)
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out compilation, out var diagnostics);

        // We can now assert things about the resulting compilation:
        Assert.Empty(diagnostics); // there were no diagnostics created by the generators
        var aggregateDiagnostics = compilation.GetDiagnostics();
        Assert.Empty(aggregateDiagnostics); // verify the compilation with the added source has no diagnostics

        // Or we can look at the results directly:
        var result = driver.GetRunResult();

        // The runResult contains the combined results of all generators passed to the driver
        Assert.Empty(result.Diagnostics);

        return result;
    }

    private CSharpCompilation CreateCompilation(String source, out SyntaxTree sourceTree)
    {
        var options = CreateCompilationOptions();
        sourceTree = CSharpSyntaxTree.ParseText(source, _parseOptions);
        var attributeTree = CSharpSyntaxTree.ParseText(
            """
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations

            // Licensed to the .NET Foundation under one or more agreements.
            // The .NET Foundation licenses this file to you under the MIT license.

            namespace System.Diagnostics.CodeAnalysis
            {
                /// <summary>
                /// Specifies that when a method returns <see cref="ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.
                /// </summary>
                [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false)]
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                internal sealed class NotNullWhenAttribute : global::System.Attribute
                {
                    /// <summary>
                    /// Initializes the attribute with the specified return value condition.
                    /// </summary>
                    /// <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
                    public NotNullWhenAttribute(bool returnValue)
                    {
                        ReturnValue = returnValue;
                    }

                    /// <summary>Gets the return value condition.</summary>
                    public bool ReturnValue { get; }
                }
            }
            """, _parseOptions);

        var result = CSharpCompilation.Create(
            assemblyName: null,
            syntaxTrees: [sourceTree, attributeTree],
            references: [.. _references],
            options: options);

        return result;
    }
    private static CSharpCompilationOptions CreateCompilationOptions()
    {
        String[] args = ["/warnaserror"];
#pragma warning disable RS1035 // Do not use APIs banned for analyzers (not an analyzer????)
        var commandLineArguments = CSharpCommandLineParser.Default.Parse(args, baseDirectory: Environment.CurrentDirectory, sdkDirectory: Environment.CurrentDirectory);
#pragma warning restore RS1035 // Do not use APIs banned for analyzers
        var result = commandLineArguments.CompilationOptions
            .WithOutputKind(OutputKind.DynamicallyLinkedLibrary);

        return result;
    }
}
