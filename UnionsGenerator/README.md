# Unions

Read about union types here: https://en.wikipedia.org/wiki/Union_type

## Licensing

This source code generator is licensed to you under the GplV3 (see the [license](LICENSE.txt)). The code generated by the tool, is however not subject to this license, but rather the license of whatever project it is being used in.

## Features

- generate rich examination and conversion api
- automatic relation type detection (congruency, superset, subset, intersection)
- generate conversion operators
- generate meaningful api names like `myUnion.IsResult` or `MyUnion.CreateFromResult(result)`
- generate the most efficient impementation for your usecase and optimize against boxing or size constraints
- group representable types and use members like `myUnion.IsNumber`
- use `System.Text.Json` serialization

## Installation

Package Reference:
```
	<ItemGroup>
	  <PackageReference Include="RhoMicro.CodeAnalysis.UnionsGenerator" Version="*">
	    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
	    <PrivateAssets>all</PrivateAssets>
	  </PackageReference>
	</ItemGroup>
```
CLI:
```
dotnet add package RhoMicro.CodeAnalysis.UnionsGenerator
```

*Note: The source code generator will generate netstandard2.0 compliant code that potentially uses newer language features. It is expected that consumers enable the `<LangVersion>11.0</LangVersion>` flag. This could change in the future to support a wider number of language versions, however the netstandard2.0 constraint will remain. The generator generates members (e.g.: [NotNullWhenAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.notnullwhenattribute?view=netstandard-2.1) ) that rely on special types not required by netstandard2.0, therefore under some circumstances (i.e. in analyzers) a polyfill (see [PolySharp](https://www.nuget.org/packages/PolySharp/#readme-body-tab)) is required.*

## How To Use

Annotate your union type with the `UnionType` attribute:
```cs
[UnionType<String, Double>]
readonly partial struct Union;
```

Use your union type:
```cs
Union u = "Hello, World!"; //implicitly converted
u = 32; //implicitly converted
u = false; //CS0029	Cannot implicitly convert type 'bool' to 'Union'
```

### Available Attributes and Instructions

#### `UnionTypeAttribute<T0>` and `UnionTypeAttribute`

##### General Usage

Use `UnionTypeAttribute<T0>` to add `T0` to the list of representable types:
```cs
[UnionType<Int32>]
[UnionType<String>]
partial struct IntOrString;
```
Usage:
```cs
IntOrString u = "Hello, World!"; //implicitly converted
u = 32; //implicitly converted
```
Use `UnionTypeAttribute` on type parameters to add the targeted type parameter to the list of representable types:
```cs
partial struct GenericUnion<[UnionType] T0, [UnionType] T1>;
```
Usage:
```cs
var u = GenericUnion<Int32, String>.CreateFromT1("Hello, World!");
u = GenericUnion<Int32, String>.CreateFromT0(32);
```
*Note: due to compiler restrictions no conversions from or to generic type parameters are generated. Using factory methods is an alternative way of creating union instances.*

##### Alias

Define aliae for generated members using `Alias` , e.g.: 
```cs
[UnionType<List<String>>(Alias = "MultipleNames")]
[UnionType<String>(Alias = "SingleName")]
partial struct Names;
```
Usage:
```cs
Names n = "John";
if(n.IsSingleName)
{
    var singleName = n.AsSingleName;
} else if(n.IsMultipleNames)
{
    var multipleNames = n.AsMultipleNames;
}
```

##### Options

Define miscellaneous behaviour for the represented type using `Options`.

###### ImplicitConversionIfSolitary

Instructs the generator to emit an implicit conversion to the representable type if it is the only one.
In effect, this option will enable the union type to act as an alias wrapper for the representable type.

This option is enabled by default.

```cs
[UnionType<Int32>(Options = UnionTypeOptions.ImplicitConversionIfSolitary)]
partial struct Int32Alias;
```
Usage:
```cs
var i = 32;
Int32Alias u = i;
i = u;
```

###### Nullable

Instructs the generator to treat the representable reference type 
as nullable, allowing for `null` arguments in factories, conversions etc.

```cs
[UnionType<String>(Options = UnionTypeOptions.Nullable)]
[UnionType<List<String>>]
partial struct NullableStringUnion;
```
Usage:
```cs
NullableStringUnion u = (String?)null;
u = new List<String>();
u = "Nonnull String";
u = (List<String>?)null; //CS8604 - Possible null reference argument for parameter.
```

##### Storage

Optimize the generated storage implementation for the representable type against boxing or size constraints using `Storage`.

###### Auto

The generator will automatically decide on a storage strategy.

If the representable type is known to be a value type,
this will store values of that type inside a shared value type container.
Boxing will not occur.

If the representable type is known to be a reference type,
this will store values of that type inside a shared reference type container.

If the representable type is neither known to be a reference type
nor a value type, this option will cause values of that type to 
be stored inside a shared reference type container.
If the representable type is a generic type parameter,
boxing will occur for value type arguments to that parameter.

###### Reference

The generator will always store values of the representable type
inside a shared reference type container.

If the representable type is known to be a value type,
boxing will occur.

If the representable type is a generic type parameter,
boxing will occur for value type arguments to that parameter.

###### Value

The generator will attempt to store values of the representable type
inside a value type container.

If the representable type is known to be a value type,
this will store values of that type inside a shared value type container.
Boxing will not occur.

If the representable type is known to be a reference type,
this will store values of that type inside a shared reference type container.
Boxing will not occur.

If the representable type is neither known to be a reference type
nor a value type, this option will cause values of that type to 
be stored inside a shared value type container.
If the representable type is a generic type parameter,
an exception of type TypeLoadException will occur for
reference type arguments to that parameter.

###### Field

The generator will attempt to store values of the representable type
inside a dedicated container for that type.

If the representable type is known to be a value type,
this will store values of that type inside a dedicated 
value type container.
Boxing will not occur.

If the representable type is known to be a reference type,
this will store values of that type inside a 
dedicated reference type container.

If the representable type is neither known to be a reference type
nor a value type, this option will cause values of that type to 
be stored inside a dedicated strongly typed container.
Boxing will not occur.

##### Groups

Group representable types into categories by assigning `Groups`:
```cs
[UnionType<Int32, Single>(Groups = ["Number"])]
[UnionType<String, Char>(Groups = ["Text"])]
partial struct GroupedUnion;
```
Usage:
```cs
GroupedUnion u = "Hello, World!";
if(u.IsNumberGroup)
{
    Assert.Fail("Expected union to be text.");
}
if(!u.IsTextGroup)
{
    Assert.Fail("Expected union to be text.");
}

u = 32f;
if(!u.IsNumberGroup)
{
    Assert.Fail("Expected union to be number.");
}
if(u.IsTextGroup)
{
    Assert.Fail("Expected union to be number.");
}
```

### `UnionTypeAttribute<T0..Tn>`

The generic `UnionTypeAttribute` types allow to define multiple representable types inline. Except for `Alias`, they support all of the features that `UnionTypeAttribute<T0>` and `UnionTypeAttribute` provide. Any such features will be applied to all representable types listed in the type arguments list.

For sample usage, see [Groups](#groups).


### `UnionTypeSettingsAttribute`

Use the `UnionTypeSettingsAttribute` to supply additional instructions to the generator. The attribute may be applied to either an assembly or a union type. When targeting a union type, it defines settings specific to that type. If, however, the attribute is annotating an assembly, it supplies the default settings for every union type in that assembly.

Settings inheritance is therefore ordered like so:

- default settings are applied (see [UnionTypeSettingsAttribute](Attributes/UnionTypeSettingsAttribute.cs))
- if settings could be located on assembly, settings defined therein are applied and override default settings
- if settings could be located on union type, settings defined therein are applied and override default or assembly settings

#### Available Settings

##### `ConstructorAccessibility`

Define the accessibility of generated constructors:

- `PublicIfInconvertible`
>Generated constructors should always be private, unless 
>no conversion operators are generated for the type they 
>accept. This would be the case for interface types or 
>supertypes of the target union. 

- `Private`
> Generated constructors should always be private.

- `Public`
> Generated constructors should always be public.

##### `DiagnosticsLevel`

Define the reporting of diagnostics:

- `Info`
> Instructs the analyzer to report info diagnostics.

- `Warning`
> Instructs the analyzer to report warning diagnostics.

- `Error`
> Instructs the analyzer to report error diagnostics.

- `All`
> Instructs the analyzer to report all diagnostics.

##### `ToStringSetting`

Define how implementations of `ToString` should be generated:

- `Detailed`
> The generator will emit an implementation that returns detailed information, including:
> - the name of the union type
> - a list of types representable by the union type
> - an indication of which type is being represented by the instance
> - the value currently being represented by the instance

- `None`
> The generator will not generate an implementation of ToString.

- `Simple`
> The generator will generate an implementation that returns the result of
> calling ToString on the currently represented value.

##### `Layout`

Generate a layout attribute for size optimization:

- `Small`
> Generate an annotation optimized for size.

- `Auto`
> Do not generate any annotations.

##### Identifiers

Define various identifiers used in the generated implementation:
- `TypeDeclarationPreface`
> A raw code preface to prepend before the generated type declaration.
- `GenericTValueName`
> The name of the generic parameter for generic <c>Is</c>, <c>As</c> and factory methods. 
> Set this property in order to avoid name collisions with generic union type parameters
- `TryConvertTypeName`
> The name of the generic parameter for the <c>TryConvert</c> method. 
> Set this property in order to avoid name collisions with generic union type parameters
- `MatchTypeName`
> The name of the generic parameter for the <c>Match</c> method. 
> Set this property in order to avoid name collisions with generic union type parameters
- `TagTypeName`
> The name to use for the discriminating tag type.
- `ValueTypeContainerTypeName`
> The name to use for the container type containing value types.
- `ValueTypeContainerName`
> The name to use for the field containing value types.
- `ReferenceTypeContainerName`
> The name to use for the field containing reference types.
- `TagFieldName`
> The name to use for the field containing the discriminating tag.
- `TagNoneName`
> The name to use for the default (uninitialized) tag value.
- `JsonConverterTypeName`
> The name of the generated json converter type.

### `RelationAttribute`

This attribute defines a relation between the targeted union type the supplied type. The following relations are available:
- `Disjunct`
- `Congruent`
- `Superset`
- `Subset`
- `Intersection`

The generator will automatically detect the relation between two union types. The only requirement is for one of the two types to be annotated with the `RelationAttribute`:
```cs
[UnionType<DateTime, String, Double>]
[Relation<CongruentUnion, SubsetUnion, SupersetUnion, IntersectionUnion>]
readonly partial struct Union;

[UnionType<Double, DateTime, String>]
sealed partial class CongruentUnion;

[UnionType<DateTime, String>]
partial class SubsetUnion;

[UnionType<DateTime, String, Double, Int32>]
partial struct SupersetUnion;

[UnionType<Int16, String, Double, List<Byte>>]
partial class IntersectionUnion;
```

Upon detecting a union relation, the generator will emit conversion operators approriate to the inferred relation type:

- `Disjunct`
> There is no relation between the provided type and target type.
> They do not share any representable types.
> No conversion operators will be generated.

- `BidirectionalRelation`
> The relation is defined on both the target type as well as the provided type.
> Only for one of the two union types will conversion operators be generated.

- `Superset`
> The target type is a superset of the provided type.
> The target type may represent all of the provided types representable types.
> This means that two conversion operations will be generated:
> - an <em>implicit</em> conversion operator from the provided type to the target type
> - an <em>explicit</em> conversion operator from the target type to the provided type
> This option is not available if the provided type has already defined a relation to the target type.

- `Subset`
> The target type is a subset of the provided type.
> The provided type may represent all of the target types representable types.
> This means that two conversion operations will be generated:
> - an <em>implicit</em> conversion operator from the target type to the provided type
> - an <em>explicit</em> conversion operator from the provided type to the target type
> This option is not available if the provided type has already defined a relation to the target type.

- `Intersection`
> The target type intersects the provided type.
> The target type may represent some, but not all of the provided types representable types; and vice-versa.
> This means that two conversion operations will be generated:
> - an <em>explicit</em> conversion operator from the target type to the provided type
> - an <em>explicit</em> conversion operator from the provided type to the target type
> This option is not available if the provided type has already defined a relation to the target type.

- `Congruent`
> The target type is congruent to the provided type.
> The target type may represent all of the provided types representable types; and vice-versa.
> This means that two conversion operations will be generated:
> - an <em>implicit</em> conversion operator from the target type to the provided type
> - an <em>implicit</em> conversion operator from the provided type to the target type
> This option is not available if the provided type has already defined a relation to the target type.

## Contrived Example

In our imaginary usecase, a user shall be retrieved from the infrastructure via a name query. The following types will be found throughout the example:

```cs
sealed record User(String Name);

enum ErrorCode
{
    NotFound,
    Unauthorized
}

readonly record struct MultipleUsersError(Int32 Count);
```

The `User` type represents a user. The `ErrorCode` represents an error that does not contain additional information, like `MultipleUsersError` does. It represents multiple users having been found while only one was requested.

We define a union type to represent our imaginary query:

```cs
[UnionType<ErrorCode, MultipleUsersError, User>]
readonly partial struct GetUserResult;
```
Instances of `GetUserResult` can represent *either* an instance of `ErrorCode`, `MultipleUsersError` or `User`.

It will be used in a service fa√ßade like so:
```cs
interface IUserService
{
    GetUserResult GetUserByName(String name);
}
```
A repository abstracts over the underlying infrastructure:
```cs
interface IUserRepository
{
    IQueryable<User> UsersByName(String name);
}
```
Access violations would be communicated through the repository using the following exception type: 
```cs
sealed class UnauthorizedDatabaseAccessException : Exception;
```
An implementation of the `IUserService` is provided as follows:
```cs
sealed class UserService : IUserService
{
    public UserService(IUserRepository repository) => _repository = repository;

    private readonly IUserRepository _repository;

    public GetUserResult GetUserByName(String name)
    {
        IQueryable<User> users;
        try
        {
            users = _repository.UsersByName(name);
        } catch(UnauthorizedDatabaseAccessException)
        {
            return ErrorCode.Unauthorized;
        }

        var reifiedUsers = users.ToArray();
        if(reifiedUsers.Length == 0)
        {
            return ErrorCode.NotFound;
        } else if(reifiedUsers.Length > 1)
        {
            return new MultipleUsersError(reifiedUsers.Length);
        }

        return reifiedUsers[0];
    }
}
```
As you can see, possible representations of `GetUserResult` are implicitly converted and returned by the service. Users of `OneOf` will be familiar with this.

On the consumer side of this api, a generated `Match` function helps with transforming the union instance to another type:

```cs
sealed class UserModel
{
    public UserModel(IUserService service) => _service = service;

    private readonly IUserService _service;

    public String ErrorMessage { get; private set; } = String.Empty;
    public User? User { get; private set; }
    public void SetUser(String name)
    {
        var getUserResult = _service.GetUserByName(name);
        User = getUserResult.Match(
            HandleErrorCode,
            HandleMultipleResult,
            user => user);
    }
    private User? HandleErrorCode(ErrorCode code)
    {
        ErrorMessage = code switch
        {
            ErrorCode.NotFound => "The user could not be located.",
            ErrorCode.Unauthorized => "You are not authorized to access users.",
            _ => throw new NotImplementedException()
        };
        return null;
    }
    private User? HandleMultipleResult(MultipleUsersError result)
    {
        ErrorMessage = $"{result.Count} users have been located. The name was not precise enough.";
        return null;
    }
}
```

Here is a list of some generated members on the `GetUserResult` union type (implementations and some details have been elided):
```cs
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/>representing an instance of <see cref="ErrorCode"/>.
/// </summary>
private GetUserResult(ErrorCode value)
	
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/>representing an instance of <see cref="MultipleUsersError"/>.
/// </summary>
private GetUserResult(MultipleUsersError value)
	
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/>representing an instance of <see cref="User"/>.
/// </summary>
private GetUserResult(User value)
		
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/> representing an instance of <see cref="ErrorCode"/>.
/// </summary>
/// <param name="value">
/// The value to be represented by the new instance of <see cref="GetUserResult"/>.
/// </param>
/// <returns>
/// A new instance of <see cref="GetUserResult"/> representing <paramref name="value"/>.
/// </returns>
public static GetUserResult CreateFromErrorCode([RhoMicro.CodeAnalysis.UnionTypeFactory]ErrorCode value)
	
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/> representing an instance of <see cref="MultipleUsersError"/>.
/// </summary>
/// <param name="value">
/// The value to be represented by the new instance of <see cref="GetUserResult"/>.
/// </param>
/// <returns>
/// A new instance of <see cref="GetUserResult"/> representing <paramref name="value"/>.
/// </returns>
public static GetUserResult CreateFromMultipleUsersError([RhoMicro.CodeAnalysis.UnionTypeFactory]MultipleUsersError value)
	
/// <summary>
/// Creates a new instance of <see cref="GetUserResult"/> representing an instance of <see cref="User"/>.
/// </summary>
/// <param name="value">
/// The value to be represented by the new instance of <see cref="GetUserResult"/>.
/// </param>
/// <returns>
/// A new instance of <see cref="GetUserResult"/> representing <paramref name="value"/>.
/// </returns>
public static GetUserResult CreateFromUser([RhoMicro.CodeAnalysis.UnionTypeFactory]User value)

/// <summary>
/// Attempts to create an instance of <see cref="GetUserResult"/> from an instance of <typeparamref name="TValue"/>.
/// </summary>
/// <param name="value">
/// The value from which to attempt to create an instance of <see cref="GetUserResult"/>.
/// </param>
/// <param name="result">
/// If an instance of <see cref="GetUserResult"/> could successfully be created, this parameter will contain the newly created instance; otherwise, <see langword="default"/>.
/// </param>
/// <returns>
/// <see langword="true"/> if an instance of <see cref="GetUserResult"/> could successfully be created; otherwise, <see langword="false"/>.
/// </returns>
public static System.Boolean TryCreate<TValue>(TValue value,  out GetUserResult result)

/// <summary>
/// Creates an instance of <see cref="GetUserResult"/> from an instance of <typeparamref name="TValue"/>.
/// </summary>
/// <param name="value">
/// The value from which to create an instance of <see cref="GetUserResult"/>.
/// </param>
/// <returns>
/// A new instance of <see cref="GetUserResult"/> representing <paramref name="value"/>.
/// </returns>
public static GetUserResult Create<TValue>(TValue value)
		
/// <summary>
/// Invokes a handler based on the type of value being represented.
/// </summary>
/// <param name="onErrorCode">
/// The handler to invoke if the union is currently representing an instance of <see cref="ErrorCode"/>.
/// </param>
/// <param name="onMultipleUsersError">
/// The handler to invoke if the union is currently representing an instance of <see cref="MultipleUsersError"/>.
/// </param>
/// <param name="onUser">
/// The handler to invoke if the union is currently representing an instance of <see cref="User"/>.
/// </param>
public void Switch(
	System.Action<ErrorCode> onErrorCode,
	System.Action<MultipleUsersError> onMultipleUsersError,
	System.Action<User> onUser)
		
/// <summary>
/// Invokes a projection based on the type of value being represented.
/// </summary>
/// <param name="onErrorCode">
/// The projection to invoke if the union is currently representing an instance of <see cref="ErrorCode"/>.
/// </param>
/// <param name="onMultipleUsersError">
/// The projection to invoke if the union is currently representing an instance of <see cref="MultipleUsersError"/>.
/// </param>
/// <param name="onUser">
/// The projection to invoke if the union is currently representing an instance of <see cref="User"/>.
/// </param>
/// <typeparam name="TMatchResult">
/// The type of value produced by the projections passed.
/// </typeparam>
/// <returns>
/// The projected value.
/// </returns>
public TMatchResult Match<TMatchResult>(
	System.Func<ErrorCode, TMatchResult> onErrorCode,
	System.Func<MultipleUsersError, TMatchResult> onMultipleUsersError,
	System.Func<User, TMatchResult> onUser)
		
/// <summary>
/// Gets the types of value this union type can represent.
/// </summary>
public static System.Collections.Generic.IReadOnlyCollection<System.Type> RepresentableTypes { get; }

/// <summary>
/// Gets the type of value represented by this instance.
/// </summary>
public System.Type RepresentedType
		
		
/// <summary>
/// Gets a value indicating whether this instance is representing a value of type <see cref="ErrorCode"/>.
/// </summary>
public System.Boolean IsErrorCode
	
/// <summary>
/// Gets a value indicating whether this instance is representing a value of type <see cref="MultipleUsersError"/>.
/// </summary>
public System.Boolean IsMultipleUsersError
	
/// <summary>
/// Gets a value indicating whether this instance is representing a value of type <see cref="User"/>.
/// </summary>
public System.Boolean IsUser
	
/// <summary>
/// Retrieves the value represented by this instance as a <see cref="ErrorCode"/>.
/// </summary>
public ErrorCode AsErrorCode
	
/// <summary>
/// Retrieves the value represented by this instance as a <see cref="MultipleUsersError"/>.
/// </summary>
public MultipleUsersError AsMultipleUsersError
	
/// <summary>
/// Retrieves the value represented by this instance as a <see cref="User"/>.
/// </summary>
public User? AsUser
		
/// <summary>
/// Determines whether this instance is representing a value of type <see cref="ErrorCode"/>.
/// </summary>
/// <returns>
/// <see langword="true"/> if this instance is representing a value of type <see cref="ErrorCode"/>; otherwise, <see langword="false"/>.
/// </returns>
/// <param name="value">
/// If this instance is representing a value of type <see cref="ErrorCode"/>, this parameter will contain that value; otherwise, <see langword="default"/>.
/// </param>
public System.Boolean TryAsErrorCode( out ErrorCode value)
	
/// <summary>
/// Determines whether this instance is representing a value of type <see cref="MultipleUsersError"/>.
/// </summary>
/// <returns>
/// <see langword="true"/> if this instance is representing a value of type <see cref="MultipleUsersError"/>; otherwise, <see langword="false"/>.
/// </returns>
/// <param name="value">
/// If this instance is representing a value of type <see cref="MultipleUsersError"/>, this parameter will contain that value; otherwise, <see langword="default"/>.
/// </param>
public System.Boolean TryAsMultipleUsersError( out MultipleUsersError value)
	
/// <summary>
/// Determines whether this instance is representing a value of type <see cref="User"/>.
/// </summary>
/// <returns>
/// <see langword="true"/> if this instance is representing a value of type <see cref="User"/>; otherwise, <see langword="false"/>.
/// </returns>
/// <param name="value">
/// If this instance is representing a value of type <see cref="User"/>, this parameter will contain that value; otherwise, <see langword="default"/>.
/// </param>
public System.Boolean TryAsUser([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out User value)

/// <summary>
/// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.
/// </summary>
/// <typeparam name="TValue">
/// The type whose representation in this instance to determine.
/// </typeparam>
/// <returns>
/// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.
/// </returns>
public System.Boolean Is<TValue>()

/// <summary>
/// Determines whether this instance is representing a value of type <typeparamref name="TValue"/>.
/// </summary>
/// <param name="value">
/// If this instance is representing a value of type <typeparamref name="TValue"/>, this parameter will contain that value; otherwise, <see langword="default"/>.
/// </param>
/// <typeparam name="TValue">
/// The type whose representation in this instance to determine.
/// </typeparam>
/// <returns>
/// <see langword="true"/> if this instance is representing a value of type <typeparamref name="TValue"/>; otherwise, <see langword="false"/>.
/// </returns>
public System.Boolean Is<TValue>(out TValue? value)

/// <summary>
/// Determines whether this instance is representing an instance of <paramref name="type"/>.
/// </summary>
/// <param name="type">
/// The type whose representation in this instance to determine.
/// </param>
/// <returns>
/// <see langword="true"/> if this instance is representing an instance of <paramref name="type"/>; otherwise, <see langword="false"/>.
/// </returns>
public System.Boolean Is(System.Type type)

/// <summary>
/// Retrieves the value represented by this instance as an instance of <typeparamref name="TValue"/>.
/// </summary>
/// <typeparam name="TValue">
/// The type to retrieve the represented value as.
/// </typeparam>
/// <returns>
/// The currently represented value as an instance of <typeparamref name="TValue"/>.
/// </returns>
public TValue As<TValue>()
		
/// <inheritdoc/>
public override System.String ToString()
		
/// <inheritdoc/>
public override System.Int32 GetHashCode()
		
/// <inheritdoc/>
public override System.Boolean Equals(System.Object? obj)

/// <inheritdoc/>
public System.Boolean Equals(GetUserResult other)

public static System.Boolean operator ==(GetUserResult a, GetUserResult b) => a.Equals(b);
public static System.Boolean operator !=(GetUserResult a, GetUserResult b) => !a.Equals(b);
		
	/// <summary>
/// Converts an instance of the representable type <see cref="ErrorCode"/> to the union type <see cref="GetUserResult"/>.
/// </summary>
/// <param name="value">
/// The value to convert.
/// </param>
/// <returns>
/// The union type instance.
/// </returns>
public static implicit operator GetUserResult(ErrorCode value)
	
/// <summary>
/// Converts an instance of the union type <see cref="GetUserResult"/> to the representable type <see cref="ErrorCode"/>.
/// </summary>
/// <param name="union">
/// The union to convert.
/// </param>
/// <returns>
/// The represented value.
/// </returns>
public static explicit operator ErrorCode(GetUserResult union)

/// <summary>
/// Converts an instance of the representable type <see cref="MultipleUsersError"/> to the union type <see cref="GetUserResult"/>.
/// </summary>
/// <param name="value">
/// The value to convert.
/// </param>
/// <returns>
/// The union type instance.
/// </returns>
public static implicit operator GetUserResult(MultipleUsersError value)

/// <summary>
/// Converts an instance of the union type <see cref="GetUserResult"/> to the representable type <see cref="MultipleUsersError"/>.
/// </summary>
/// <param name="union">
/// The union to convert.
/// </param>
/// <returns>
/// The represented value.
/// </returns>
public static explicit operator MultipleUsersError(GetUserResult union)

/// <summary>
/// Converts an instance of the representable type <see cref="User"/> to the union type <see cref="GetUserResult"/>.
/// </summary>
/// <param name="value">
/// The value to convert.
/// </param>
/// <returns>
/// The union type instance.
/// </returns>
public static implicit operator GetUserResult(User value)

/// <summary>
/// Converts an instance of the union type <see cref="GetUserResult"/> to the representable type <see cref="User"/>.
/// </summary>
/// <param name="union">
/// The union to convert.
/// </param>
/// <returns>
/// The represented value.
/// </returns>
public static explicit operator User(GetUserResult union)
```
