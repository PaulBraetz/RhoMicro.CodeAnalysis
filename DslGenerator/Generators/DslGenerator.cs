namespace RhoMicro.CodeAnalysis.DslGenerator.Generators;

using Microsoft.CodeAnalysis;
using RhoMicro.CodeAnalysis.Generated;
using RhoMicro.CodeAnalysis.DslGenerator.Lexing;
using RhoMicro.CodeAnalysis.DslGenerator.Parsing;
using RhoMicro.CodeAnalysis.DslGenerator.Grammar;
using RhoMicro.CodeAnalysis.UtilityGenerators;
using RhoMicro.CodeAnalysis.DslGenerator.Analysis;
using System.Text.RegularExpressions;
using System.Collections.Immutable;
using System.Text;

/// <summary>
/// Generates utilities for domain specific languages.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DslGenerator : IIncrementalGenerator
{
    const String _grammarFileExtension = ".rmbnf";
    static readonly Regex _identifierPattern = new(@"[_a-zA-Z]+[_a-zA-Z0-9]*", RegexOptions.Compiled);
    static readonly IEqualityComparer<(String source, DiagnosticsCollection diagnostics)> _sourceDiagnosticsTupleComparer =
        new EqualityComparerStrategy<(String source, DiagnosticsCollection diagnostics)>(
                (x, y) => x.source == y.source,
                obj => obj.source.GetHashCode());
    static readonly IEqualityComparer<ImmutableArray<(String source, DiagnosticsCollection diagnostics)>> _sourceDiagnosticsTupleArrayComparer =
        new ImmutableArrayCollectionEqualityComparer<(String source, DiagnosticsCollection diagnostics)>(_sourceDiagnosticsTupleComparer);

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.AdditionalTextsProvider
            .Where(text => Path.GetExtension(text.Path) == _grammarFileExtension)
            .Select((text, ct) => (tokenizeResult: new Tokenizer().Tokenize(text.GetText(ct)?.ToString() ?? String.Empty, ct, text.Path), fileName: Path.GetFileNameWithoutExtension(text.Path)))
            .Select((t, ct) => (parseResult: new Parser().Parse(t.tokenizeResult, ct), t.fileName))
            .Select((t, ct) => (t.parseResult, isNamed: t.parseResult.RuleList is NamedRuleList, t.fileName))
            .Select((t, ct) => (t.parseResult, name: t.isNamed ? ((NamedRuleList)t.parseResult.RuleList).Name.ToDisplayString() : t.fileName, type: t.isNamed ? nameof(NamedRuleList) : nameof(RuleList)))
            .Where(t => _identifierPattern.Match(t.name).Value == t.name)
            .Select((t, ct) =>
            {
                var (parseResult, name, type) = t;
                var (ruleList, diagnostics) = parseResult;
                var initialization = ruleList.ToMetaString();
                var comment = ruleList.ToDisplayString().Replace("\n", "\n\t/// </c></para>\n\t/// <para><c>\n\t/// ");
                var source =
                $$"""
                    /// <summary>
                    /// <para>
                    /// Matches the following grammar:
                    /// </para>
                    /// <para><c>
                    /// {{comment}} 
                    /// </c></para>
                    /// </summary>
                    public static {{type}} {{name}} { get; } = {{initialization}};
                """;

                return (source, diagnostics);
            })
            .WithComparer(_sourceDiagnosticsTupleComparer)
            .Collect()
            .WithComparer(_sourceDiagnosticsTupleArrayComparer)
            .Select((sourceTuples, ct) =>
            {
                var diagnosticsAggregator = new DiagnosticsCollection();
                var sourceBuilder = new StringBuilder("// <auto-generated>")
                    .AppendLine()
                    .Append("// This file was last generated by the RhoMicro.CodeAnalysis.DslGenerator on ")
                    .AppendLine(DateTimeOffset.Now.ToString())
                    .AppendLine("// </auto-generated>")
                    .AppendLine()
                    .Append(
                    """
                    namespace RhoMicro.CodeAnalysis.DslGenerator.Generated.Grammar;

                    static class FileGeneratedRuleLists
                    {

                    """);
                for(var i = 0; i < sourceTuples.Length; i++)
                {
                    var (source, diagnostics) = sourceTuples[i];
                    _ = sourceBuilder.AppendLine(source);
                    diagnosticsAggregator.Add(diagnostics);
                }

                var ruleListsSource = sourceBuilder.AppendLine("}").ToString();

                return (source: ruleListsSource, diagnostics: diagnosticsAggregator);
            })
            .WithComparer(new EqualityComparerStrategy<(String source, DiagnosticsCollection diagnostics)>(
                (x, y) => x.source == y.source,
                obj => obj.source.GetHashCode()));

        context.RegisterSourceOutput(provider, (ctx, data) =>
        {
            var (source, diagnostics) = data;
            ctx.AddSource("FileGeneratedRuleLists.g.cs", source);
            diagnostics.ReportToContext(ctx);
        });
        IncludedFileSources.RegisterToContext(context);
    }
}
