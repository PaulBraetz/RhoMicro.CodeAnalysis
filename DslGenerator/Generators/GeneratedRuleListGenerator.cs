namespace RhoMicro.CodeAnalysis.DslGenerator.Generators;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using RhoMicro.CodeAnalysis.DslGenerator.Parsing;
using RhoMicro.CodeAnalysis.UtilityGenerators;

using System.Collections.Immutable;
using System.Text;
using System.Xml.Schema;

[Generator(LanguageNames.CSharp)]
internal class GeneratedRuleListGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForGeneratedRuleListAttribute(
            IsGeneratorTarget,
            (ctx, ct) =>
            {
                ct.ThrowIfCancellationRequested();

                var sourceText = GetRawSourceText(ctx, ct);
                var head = GetHead(ctx, ct);
                var tail = GetTail(ctx, ct);

                var result = (sourceText, head, tail);

                return result;
            })
            .Where(t => !String.IsNullOrEmpty(t.sourceText))
            .Collect()
            .WithComparer(ImmutableArrayCollectionEqualityComparer<(String? sourceText, String head, String tail)>.Default)
            .Select(GetFinalSource);

        context.RegisterSourceOutput(provider, (ctx, source) =>
            ctx.AddSource("AttributeGeneratedRuleLists.g.cs", source));
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource($"{nameof(GeneratedRuleListAttribute)}.g.cs", GeneratedRuleListAttribute.SourceText));
    }

    private static String GetFinalSource(
        ImmutableArray<(String? sourceText, String head, String tail)> sources,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var resultBuilder = new StringBuilder();
        _ = resultBuilder.AppendLine("// <auto-generated>")
            .Append("// This file was last generated by the RhoMicro.CodeAnalysis.DslGenerator on ").AppendLine(DateTimeOffset.Now.ToString())
            .AppendLine("// </auto-generated>")
            .AppendLine("#pragma disable warning");

        for(var i = 0; i < sources.Length; i++)
        {
            var (sourceText, head, tail) = sources[i];
            _ = resultBuilder.AppendLine(head).AppendLine(sourceText).AppendLine(tail);
        }

        var result = resultBuilder.ToString();

        return result;
    }
    static readonly SymbolDisplayFormat _typeSignatureNameFormat =
        SymbolDisplayFormat.MinimallyQualifiedFormat.WithGenericsOptions(SymbolDisplayGenericsOptions.IncludeTypeParameters);
    static readonly SymbolDisplayFormat _namespaceFormat =
        SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted);
    private static String GetHead(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var resultBuilder = new StringBuilder();
        var parent = (ctx.TargetSymbol as IMethodSymbol)!.ContainingType;
        appendHead(parent);
        var result = resultBuilder.ToString();
        return result;

        void appendHead(INamedTypeSymbol parent)
        {
            if(parent.ContainingType != null)
            {
                appendHead(parent.ContainingType);
            } else if(!parent.ContainingNamespace.IsGlobalNamespace)
            {
                _ = resultBuilder
                    .Append("namespace ")
                    .AppendLine(parent.ContainingNamespace.ToDisplayString(_namespaceFormat))
                    .AppendLine("{");
            }

            var typeModifier = parent.IsRecord ?
                parent.IsReferenceType ?
                "record" :
                "record struct " :
                parent.IsReferenceType ?
                "class " :
                "struct ";

            _ = resultBuilder!
                .Append("partial ")
                .Append(typeModifier)
                .AppendLine(parent.ToDisplayString(_typeSignatureNameFormat))
                .AppendLine("{");
        }
    }
    private static String GetTail(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var resultBuilder = new StringBuilder();
        var parent = (ctx.TargetSymbol as IMethodSymbol)!.ContainingType;
        while(parent != null)
        {
            _ = resultBuilder!.AppendLine("}");
            parent = parent.ContainingType;
        }

        if(!ctx.TargetSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            _ = resultBuilder!.AppendLine("}");
        }

        var result = resultBuilder.ToString();
        return result;
    }
    private static String? GetRawSourceText(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if(((IMethodSymbol)ctx.TargetSymbol).ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) !=
            "global::RhoMicro.CodeAnalysis.DslGenerator.Generated.Grammar.RuleList")
        {
            return null;
        }

        cancellationToken.ThrowIfCancellationRequested();

        var sourceText = ctx.Attributes[0].ConstructorArguments[0].Value as String ?? String.Empty;
        var ruleList = Parser.Instance.Parse(sourceText, cancellationToken).RuleList.ToMetaString();
        var result = $"partial static global::RhoMicro.CodeAnalysis.DslGenerator.Generated.Grammar.RuleList {ctx.TargetSymbol.Name}() => {ruleList};";

        return result;
    }

    private static Boolean IsGeneratorTarget(SyntaxNode node, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if(node is not MethodDeclarationSyntax mds || mds.ParameterList.Parameters.Count != 0)
            return false;

        cancellationToken.ThrowIfCancellationRequested();

        var isStatic = false;
        var isPartial = false;
        for(var i = 0; i < mds.Modifiers.Count; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if(mds.Modifiers[i].IsKind(SyntaxKind.StaticKeyword))
            {
                isStatic = true;
                if(isPartial)
                    break;
            } else if(mds.Modifiers[i].IsKind(SyntaxKind.PartialKeyword))
            {
                isPartial = true;
                if(isStatic)
                    break;
            }
        }

        if(!(isStatic || isPartial))
            return false;

        cancellationToken.ThrowIfCancellationRequested();

        var result = mds.Body == null;

        return result;
    }
}
