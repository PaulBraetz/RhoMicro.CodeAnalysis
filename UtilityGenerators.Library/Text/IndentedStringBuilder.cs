namespace RhoMicro.CodeAnalysis.Library.Text;

using Microsoft.CodeAnalysis;

using RhoMicro.CodeAnalysis.Library;

using System.Collections.Immutable;
using System.Net.Http.Headers;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

sealed class IndentedStringBuilder(IndentedStringBuilderOptions options) : IEquatable<IndentedStringBuilder?>
{
    public IndentedStringBuilder() : this(IndentedStringBuilderOptions.Default)
    {
        if(!_options.PrependMarkerComment)
        {
            _ = String.IsNullOrWhiteSpace(_options.GeneratorName) ?
                AppendLine("// <auto-generated />") :
                AppendLine("// <auto-generated>")
                .Append("// This file was last generated by ")
                .Append(_options.GeneratorName)
                .Append(" at ")
                .AppendLine(DateTimeOffset.Now.ToString())
                .AppendLine("// </auto-generated>");
        }

        if(_options.PrependWarningDisablePragma)
            _ = _builder.AppendLine("#pragma warning diasble");

        if(_options.PrependNullableEnable)
            _ = _builder.AppendLine("#nullable enable");
    }

    #region Fields
    private readonly StringBuilder _builder = new();
    private readonly IndentedStringBuilderOptions _options = options;
    private readonly Stack<Block> _blocks = new();
    private Int32 _indentationLevel;
    private Block? _lastBlock;
    private Boolean _lastWasNewLine;
    #endregion
    #region Open Block
    void OpenBlockCore(Block block)
    {
        var delimiter = block.OpeningDelimiter;
        ApplyNewLineAfterBlockClose();
        AppendSingleLineCore();
        AppendCoreSimple(delimiter, default);
        AppendLineCore();
        _lastBlock = null;
        _blocks.Push(block);

        if(block.IncreaseIndentation)
            IndentCore();
    }
    public IndentedStringBuilder OpenBlock()
    {
        OpenBlockCore(_options.DefaultBlock);
        return this;
    }
    public IndentedStringBuilder OpenBlock(Block block)
    {
        OpenBlockCore(block);
        return this;
    }
    public IndentedStringBuilder OpenBracketsBlock() => OpenBlock(Block.Brackets);
    public IndentedStringBuilder OpenBracketsBreakBlock() => OpenBlock(Block.BracketsBreak);
    public IndentedStringBuilder OpenBracesBlock() => OpenBlock(Block.Braces);
    public IndentedStringBuilder OpenBracesBreakBlock() => OpenBlock(Block.BracesBreak);
    public IndentedStringBuilder OpenParensBlock() => OpenBlock(Block.Parens);
    public IndentedStringBuilder OpenParensBreakBlock() => OpenBlock(Block.ParensBreak);
    public IndentedStringBuilder OpenAngledBlock() => OpenBlock(Block.Angled);
    public IndentedStringBuilder OpenAngledBreakBlock() => OpenBlock(Block.AngledBreak);
    public IndentedStringBuilder OpenRegionBlock(String name) => OpenBlock(Block.Region(name));
    public IndentedStringBuilder OpenDocCommentBlock(String name) => OpenBlock(Block.DocComment(name));
    public IndentedStringBuilder OpenDocCommentBlock(String name, String attributeName, String attributeValue) => OpenBlock(Block.DocComment(name, attributeName, attributeValue));
    #endregion
    #region Open Block Scope
    public BlockScope OpenBlockScope() => new(OpenBlock());
    public BlockScope OpenBlockScope(Block block) => new(OpenBlock(block));
    public BlockScope OpenBracketsBlockScope() => new(OpenBracketsBlock());
    public BlockScope OpenBracketsBreakBlockScope() => new(OpenBracketsBreakBlock());
    public BlockScope OpenBracesBlockScope() => new(OpenBracesBlock());
    public BlockScope OpenBracesBreakBlockScope() => new(OpenBracesBreakBlock());
    public BlockScope OpenParensBlockScope() => new(OpenParensBlock());
    public BlockScope OpenParensBreakBlockScope() => new(OpenParensBreakBlock());
    public BlockScope OpenAngledBlockScope() => new(OpenAngledBlock());
    public BlockScope OpenAngledBreakScope() => new(OpenAngledBreakBlock());
    public BlockScope OpenRegionBlockScope(String name) => new(OpenRegionBlock(name));
    public BlockScope OpenDocCommentBlockScope(String name) => new(OpenBlock(Block.DocComment(name)));
    public BlockScope OpenDocCommentBlockScope(String name, String attributeName, String attributeValue) => new(OpenBlock(Block.DocComment(name, attributeName, attributeValue)));
    #endregion
    #region Close Block
    void CloseBlockCore()
    {
        DetentCore();

        var block = _blocks.Pop();
        AppendSingleLineCore();
        _lastBlock = null;
        AppendCore(block.ClosingDelimiter, default);
        AppendLineCore();
        _lastBlock = block;
    }
    public IndentedStringBuilder CloseBlock()
    {
        if(_blocks.Count == 0)
            return this;

        CloseBlockCore();
        return this;
    }
    public IndentedStringBuilder CloseAllBlocks()
    {
        while(_blocks.Count > 0)
        {
            CloseBlockCore();
        }

        return this;
    }
    #endregion
    #region Indent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void IndentCore()
    {
        if(_indentationLevel < Int32.MaxValue)
            _indentationLevel++;
    }
    public IndentScope CreateIndentScope() => new(Indent());
    public IndentedStringBuilder Indent()
    {
        IndentCore();
        return this;
    }
    void ApplyIndentation()
    {
        if(!_lastWasNewLine)
            return;

        for(var i = 0; i < _indentationLevel; i++)
        {
            _ = _options.Indentation.IsString ?
                _builder.Append((String)_options.Indentation) :
                _builder.Append((Char)_options.Indentation);
        }

        _lastWasNewLine = false;
    }
    #endregion
    #region Detent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void DetentCore()
    {
        if(_indentationLevel > 0)
            _indentationLevel--;
    }
    public IndentedStringBuilder Detent()
    {
        DetentCore();
        return this;
    }
    #endregion
    #region Append String
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(String value) => _builder.Append(value);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreSimple(String value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(String value)
    {
        ApplyNewLineAfterBlockClose();
        AppendCoreSimple(value);
    }
    public IndentedStringBuilder Append(String value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params String[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<String> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<String> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Char
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(Char value) => _builder.Append(value);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreSimple(Char value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(Char value)
    {
        ApplyNewLineAfterBlockClose();
        AppendCoreSimple(value);
    }
    public IndentedStringBuilder Append(Char value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params Char[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<Char> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<Char> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append T
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        value?.AppendTo(this, cancellationToken);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreSimple<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        ApplyIndentation();
        AppendCoreNoIndentation(value, cancellationToken);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        ApplyNewLineAfterBlockClose();
        AppendCoreSimple(value, cancellationToken);
    }
    public IndentedStringBuilder Append<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        AppendCore(value, cancellationToken);
        return this;
    }
    public IndentedStringBuilder Append<T>(CancellationToken cancellationToken, params T[] values)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        for(var i = 0; i < values.Length; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(values[i], cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(ImmutableArray<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        for(var i = 0; i < values.Length; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(values[i], cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        foreach(var value in values)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(value, cancellationToken);
        }

        return this;
    }
    #endregion
    #region Append Join
    public IndentedStringBuilder AppendJoin(IEnumerable<String> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<String> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin(IEnumerable<Char> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<Char> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
        => AppendJoin(", ", values, cancellationToken);
    public IndentedStringBuilder AppendJoin<T>(StringOrChar separator, IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current, cancellationToken);

        while(enumerator.MoveNext())
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(separator, cancellationToken);
            AppendCore(enumerator.Current, cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
        => AppendJoinLines(',', values, cancellationToken);
    public IndentedStringBuilder AppendJoinLines<T>(StringOrChar separator, IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current, cancellationToken);

        while(enumerator.MoveNext())
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(separator, cancellationToken);
            AppendLineCore();
            AppendCore(enumerator.Current, cancellationToken);
        }

        return this;
    }
    #endregion
    #region Append Line
    void ApplyNewLineAfterBlockClose()
    {
        if(!_lastBlock.GetValueOrDefault().AppendNewLine)
            return;

        _lastBlock = null;
        AppendLineCore();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendLineCore()
    {
        _lastWasNewLine = true;
        AppendCoreNoIndentation(_options.NewLine, default);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendSingleLineCore()
    {
        if(_lastWasNewLine)
            return;
        AppendLineCore();
    }
    public IndentedStringBuilder AppendLine()
    {
        AppendLineCore();
        return this;
    }
    public IndentedStringBuilder AppendLine(String value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine(Char value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        return Append(value, cancellationToken).AppendLine();
    }
    #endregion
    #region ToString & Equality
    public override String ToString() => _builder.ToString();
    public override Boolean Equals(Object? obj) => Equals(obj as IndentedStringBuilder);
    public Boolean Equals(IndentedStringBuilder? other) =>
        other is not null &&
        _indentationLevel == other._indentationLevel &&
        _lastWasNewLine == other._lastWasNewLine &&
        _lastBlock == other._lastBlock &&
        _blocks.SequenceEqual(other._blocks) &&
        EqualityComparer<StringBuilder>.Default.Equals(_builder, other._builder);
    public override Int32 GetHashCode() =>
        (
            _builder,
            _indentationLevel,
            _lastBlock,
            _lastWasNewLine,
            CollectionEqualityComparer<Block>.Default.GetHashCode(_blocks)
        ).GetHashCode();
    #endregion
}
