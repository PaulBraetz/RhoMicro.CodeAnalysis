namespace RhoMicro.CodeAnalysis.Library.Text;

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
partial class IndentedStringBuilder : IEquatable<IndentedStringBuilder?>
{
    public IndentedStringBuilder(IndentedStringBuilderOptions options)
    {
        _options = options;

        if(_options.PrependMarkerComment)
        {
            _ = String.IsNullOrWhiteSpace(_options.GeneratorName) ?
                AppendLine("// <auto-generated />") :
                AppendLine("// <auto-generated>")
                .Append("// This file was last generated by ")
                .Append(_options.GeneratorName)
                .Append(" at ")
                .AppendLine(DateTimeOffset.Now.ToString())
                .AppendLine("// </auto-generated>");
        }

        if(_options.PrependWarningDisablePragma)
            _ = _builder.AppendLine("#pragma warning disable");

        if(_options.PrependNullableEnable)
            _ = _builder.AppendLine("#nullable enable");

        Comment = new(this);
    }

    public IndentedStringBuilder() : this(IndentedStringBuilderOptions.Default)
    { }

    #region Fields & Properties
    public CommentBuilder Comment { get; }
    private readonly IndentedStringBuilderOptions _options;
    private readonly StringBuilder _builder = new();
    private readonly Stack<Block> _blocks = new();
    private readonly Stack<StringOrChar> _indentations = new();
    private Block? LastBlock => _blocks.Count > 0 ? _blocks.Peek() : null;
    private Boolean LastWasNewLine
    {
        get
        {
            if(_builder.Length < _options.NewLine.Length)
                return false;

            for(var i = 1; i <= _options.NewLine.Length; i++)
            {
                if(_builder[^i] != _options.NewLine[^i])
                    return false;
            }

            return true;
        }
    }
    public Operators GetOperators(CancellationToken cancellationToken) => new(this, cancellationToken);
    #endregion
    #region Open Block
    void OpenBlockCore(Block block)
    {
        var delimiter = block.OpeningDelimiter;

        if(block.PlaceDelimitersOnNewLine)
            AppendSingleLineCore();

        AppendCore(delimiter, default);

        _blocks.Push(block);

        var indentation = block.Indentation ?? _options.DefaultIndentation;
        _indentations.Push(indentation);
    }
    public IndentedStringBuilder OpenBlock(Block block)
    {
        OpenBlockCore(block);
        return this;
    }
    public IndentedStringBuilder OpenBracketsBlock() => OpenBlock(Blocks.Brackets);
    public IndentedStringBuilder OpenIndentBlock() => OpenBlock(Blocks.Indent);
    public IndentedStringBuilder OpenBracesBlock() => OpenBlock(Blocks.Braces);
    public IndentedStringBuilder OpenParensBlock() => OpenBlock(Blocks.Parens);
    public IndentedStringBuilder OpenAngledBlock() => OpenBlock(Blocks.Angled);
    public IndentedStringBuilder OpenRegionBlock(String name) => OpenBlock(Blocks.Region(name));
    #endregion
    #region Open Block Scope
    public BlockScope OpenBlockScope(Block block) => new(OpenBlock(block));
    public BlockScope OpenBracketsBlockScope() => new(OpenBracketsBlock());
    public BlockScope OpenIndentBlockScope() => new(OpenIndentBlock());
    public BlockScope OpenBracesBlockScope() => new(OpenBracesBlock());
    public BlockScope OpenParensBlockScope() => new(OpenParensBlock());
    public BlockScope OpenAngledBlockScope() => new(OpenAngledBlock());
    public BlockScope OpenRegionBlockScope(String name) => new(OpenRegionBlock(name));
    #endregion
    #region Close Block
    void CloseBlockCore()
    {
        if(!LastBlock.HasValue)
            return;

        DetentCore();

        var block = LastBlock.Value;

        if(block.PlaceDelimitersOnNewLine)
            AppendSingleLineCore();

        AppendCore(block.ClosingDelimiter, default);
        _ = _blocks.Pop();
    }
    public IndentedStringBuilder CloseBlock()
    {
        if(_blocks.Count == 0)
            return this;

        CloseBlockCore();
        return this;
    }
    public IndentedStringBuilder CloseAllBlocks()
    {
        while(_blocks.Count > 0)
        {
            CloseBlockCore();
        }

        return this;
    }
    #endregion
    #region Indent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void IndentCore() => _indentations.Push(_options.DefaultIndentation);
    public IndentScope CreateIndentScope() => new(Indent());
    public IndentedStringBuilder Indent()
    {
        IndentCore();
        return this;
    }
    void ApplyIndentation()
    {
        if(!LastWasNewLine)
            return;

        foreach(var indentation in _indentations.Reverse())
        {
            _ = indentation.IsString ?
                _builder.Append((String)indentation) :
                _builder.Append((Char)indentation);
        }
    }
    #endregion
    #region Detent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void DetentCore()
    {
        if(_indentations.Count > 0)
        {
            if(!_indentations.Peek().IsWhitespace)
                throw new InvalidOperationException("Attempted to detent non-whitespace indentation. Use 'CloseBlock' or 'CloseAllBlocks' instead.");

            _ = _indentations.Pop();
        }
    }
    public IndentedStringBuilder Detent()
    {
        DetentCore();
        return this;
    }
    #endregion
    #region Append String
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(String value) => _builder.Append(value);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(String value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public IndentedStringBuilder Append(String value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params String[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<String> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<String> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Char
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(Char value) => _builder.Append(value);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(Char value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public IndentedStringBuilder Append(Char value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params Char[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<Char> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<Char> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append T
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        value?.AppendTo(this, cancellationToken);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        ApplyIndentation();
        AppendCoreNoIndentation(value, cancellationToken);
    }
    public IndentedStringBuilder Append<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        AppendCore(value, cancellationToken);
        return this;
    }
    public IndentedStringBuilder Append<T>(CancellationToken cancellationToken, params T[] values)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        for(var i = 0; i < values.Length; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(values[i], cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(ImmutableArray<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        for(var i = 0; i < values.Length; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(values[i], cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        foreach(var value in values)
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(value, cancellationToken);
        }

        return this;
    }
    #endregion
    #region Append Join
    public IndentedStringBuilder AppendJoin(IEnumerable<String> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<String> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin(IEnumerable<Char> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<Char> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator, default);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
        => AppendJoin(", ", values, cancellationToken);
    public IndentedStringBuilder AppendJoin<T>(StringOrChar separator, IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current, cancellationToken);

        while(enumerator.MoveNext())
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(separator, cancellationToken);
            AppendCore(enumerator.Current, cancellationToken);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines<T>(IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
        => AppendJoinLines(',', values, cancellationToken);
    public IndentedStringBuilder AppendJoinLines<T>(StringOrChar separator, IEnumerable<T> values, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current, cancellationToken);

        while(enumerator.MoveNext())
        {
            cancellationToken.ThrowIfCancellationRequested();

            AppendCore(separator, cancellationToken);
            AppendLineCore();
            AppendCore(enumerator.Current, cancellationToken);
        }

        return this;
    }
    #endregion
    #region Append Line
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendLineCore() => _ = _options.NewLine.IsString ?
        _builder.Append((String)_options.NewLine) :
        _builder.Append((Char)_options.NewLine);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendSingleLineCore()
    {
        if(LastWasNewLine)
            return;

        AppendLineCore();
    }
    public IndentedStringBuilder AppendLine()
    {
        AppendLineCore();
        return this;
    }
    public IndentedStringBuilder AppendLine(String value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine(Char value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine<T>(T value, CancellationToken cancellationToken)
        where T : IIndentedStringBuilderAppendable
    {
        cancellationToken.ThrowIfCancellationRequested();

        return Append(value, cancellationToken).AppendLine();
    }
    #endregion
    #region ToString & Equality
    public override String ToString() => _builder.ToString();
    public override Boolean Equals(Object? obj) => Equals(obj as IndentedStringBuilder);
    public Boolean Equals(IndentedStringBuilder? other) =>
        other is not null &&
        CollectionEqualityComparer<StringOrChar>.Default.Equals(_indentations, other._indentations) &&
        CollectionEqualityComparer<Block>.Default.Equals(_blocks, other._blocks) &&
        EqualityComparer<StringBuilder>.Default.Equals(_builder, other._builder);
    public override Int32 GetHashCode() =>
        (
            _builder,
            CollectionEqualityComparer<StringOrChar>.Default.GetHashCode(_indentations),
            CollectionEqualityComparer<Block>.Default.GetHashCode(_blocks)
        ).GetHashCode();
    #endregion
}
