namespace RhoMicro.CodeAnalysis.Library.Text;

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
partial class IndentedStringBuilder : IEquatable<IndentedStringBuilder?>
{
    public IndentedStringBuilder(IndentedStringBuilderOptions options)
    {
        Options = options;

        if(Options.PrependMarkerComment)
        {
            _ = String.IsNullOrWhiteSpace(Options.GeneratorName) ?
                _builder.AppendLine("// <auto-generated />") :
                _builder.AppendLine("// <auto-generated>")
                    .Append("// This file was last generated by ")
                    .Append(Options.GeneratorName)
                    .Append(" at ")
                    .AppendLine(DateTimeOffset.Now.ToString())
                    .AppendLine("// </auto-generated>");
        }

        if(Options.PrependWarningDisablePragma)
            _ = _builder.AppendLine("#pragma warning disable");

        if(Options.PrependNullableEnable)
            _ = _builder.AppendLine("#nullable enable");

        Comment = new(this);
        Operators = new(this);
    }

    public IndentedStringBuilder() : this(IndentedStringBuilderOptions.Default)
    { }

    #region Fields & Properties
    public CommentBuilder Comment { get; }
    public OperatorsDecorator Operators { get; }
    public IndentedStringBuilderOptions Options { get; }
    private readonly StringBuilder _builder = new();
    private readonly Stack<Block> _blocks = new();
    private readonly Stack<StringOrChar> _indentations = new();
    private Block? LastBlock => _blocks.Count > 0 ? _blocks.Peek() : null;
    private Boolean LastWasNewLine
    {
        get
        {
            if(_builder.Length < Options.NewLine.Length)
                return false;

            for(var i = 1; i <= Options.NewLine.Length; i++)
            {
                if(_builder[^i] != Options.NewLine[^i])
                    return false;
            }

            return true;
        }
    }
    public Int32 OpenBlocks => _blocks.Count;
    #endregion
    #region Open Block
    void OpenBlockCore(Block block)
    {
        var delimiter = block.OpeningDelimiter;

        if(block.PlaceDelimitersOnNewLine)
            AppendSingleLineCore();

        AppendCore(delimiter);

        _blocks.Push(block);

        var indentation = block.Indentation ?? Options.DefaultIndentation;
        _indentations.Push(indentation);
    }
    public IndentedStringBuilder OpenBlock(Block block)
    {
        OpenBlockCore(block);
        return this;
    }
    public IndentedStringBuilder OpenBracketsBlock() => OpenBlock(Blocks.Brackets);
    public IndentedStringBuilder OpenIndentBlock() => OpenBlock(Blocks.Indent);
    public IndentedStringBuilder OpenBracesBlock() => OpenBlock(Blocks.Braces);
    public IndentedStringBuilder OpenParensBlock() => OpenBlock(Blocks.Parens);
    public IndentedStringBuilder OpenAngledBlock() => OpenBlock(Blocks.Angled);
    public IndentedStringBuilder OpenRegionBlock(String name) => OpenBlock(Blocks.Region(name));
    #endregion
    #region Open Block Scope
    public BlockScope OpenBlockScope(Block block) => new(OpenBlock(block));
    public BlockScope OpenBracketsBlockScope() => new(OpenBracketsBlock());
    public BlockScope OpenIndentBlockScope() => new(OpenIndentBlock());
    public BlockScope OpenBracesBlockScope() => new(OpenBracesBlock());
    public BlockScope OpenParensBlockScope() => new(OpenParensBlock());
    public BlockScope OpenAngledBlockScope() => new(OpenAngledBlock());
    public BlockScope OpenRegionBlockScope(String name) => new(OpenRegionBlock(name));
    #endregion
    #region Close Block
    void CloseBlockCore()
    {
        if(!LastBlock.HasValue)
            return;

        DetentCore();

        var block = LastBlock.Value;

        if(block.PlaceDelimitersOnNewLine)
            AppendSingleLineCore();

        AppendCore(block.ClosingDelimiter);
        _ = _blocks.Pop();
    }
    public IndentedStringBuilder CloseBlock()
    {
        if(_blocks.Count == 0)
            return this;

        CloseBlockCore();
        return this;
    }
    public IndentedStringBuilder CloseAllBlocks()
    {
        while(_blocks.Count > 0)
        {
            CloseBlockCore();
        }

        return this;
    }
    #endregion
    #region Indent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void IndentCore() => _indentations.Push(Options.DefaultIndentation);
    public IndentScope CreateIndentScope() => new(Indent());
    public IndentedStringBuilder Indent()
    {
        IndentCore();
        return this;
    }
    void ApplyIndentation()
    {
        if(!LastWasNewLine)
            return;

        foreach(var indentation in _indentations.Reverse())
        {
            ThrowIfCancellationRequested();

            _ = indentation.IsString ?
                _builder.Append((String)indentation) :
                _builder.Append((Char)indentation);
        }
    }
    #endregion
    #region Detent
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void DetentCore()
    {
        if(_indentations.Count > 0)
        {
            if(!_indentations.Peek().IsWhitespace)
                throw new InvalidOperationException("Attempted to detent non-whitespace indentation. Use 'CloseBlock' or 'CloseAllBlocks' instead.");

            _ = _indentations.Pop();
        }
    }
    public IndentedStringBuilder Detent()
    {
        DetentCore();
        return this;
    }
    #endregion
    #region Append String
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(String value)
    {
        ThrowIfCancellationRequested();

        _ = _builder.Append(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(String value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public IndentedStringBuilder Append(String value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params String[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<String> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<String> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Char
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation(Char value)
    {
        ThrowIfCancellationRequested();

        _ = _builder.Append(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore(Char value)
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public IndentedStringBuilder Append(Char value)
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append(params Char[] values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(ImmutableArray<Char> values)
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append(IEnumerable<Char> values)
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append T
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCoreNoIndentation<T>(T value)
        where T : IIndentedStringBuilderAppendable => value?.AppendTo(this);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void AppendCore<T>(T value)
        where T : IIndentedStringBuilderAppendable
    {
        ApplyIndentation();
        AppendCoreNoIndentation(value);
    }
    public IndentedStringBuilder Append<T>(T value)
        where T : IIndentedStringBuilderAppendable
    {
        AppendCore(value);
        return this;
    }
    public IndentedStringBuilder Append<T>(params T[] values)
        where T : IIndentedStringBuilderAppendable
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(ImmutableArray<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        for(var i = 0; i < values.Length; i++)
        {
            AppendCore(values[i]);
        }

        return this;
    }
    public IndentedStringBuilder Append<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        foreach(var value in values)
        {
            AppendCore(value);
        }

        return this;
    }
    #endregion
    #region Append Join
    public IndentedStringBuilder AppendJoin(IEnumerable<String> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<String> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<String> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin(IEnumerable<Char> values) => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines(IEnumerable<Char> values) => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines(StringOrChar separator, IEnumerable<Char> values)
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoin<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
        => AppendJoin(", ", values);
    public IndentedStringBuilder AppendJoin<T>(StringOrChar separator, IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendCore(enumerator.Current);
        }

        return this;
    }
    public IndentedStringBuilder AppendJoinLines<T>(IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
        => AppendJoinLines(',', values);
    public IndentedStringBuilder AppendJoinLines<T>(StringOrChar separator, IEnumerable<T> values)
        where T : IIndentedStringBuilderAppendable
    {
        var enumerator = values.GetEnumerator();
        if(!enumerator.MoveNext())
            return this;

        AppendCore(enumerator.Current);

        while(enumerator.MoveNext())
        {
            AppendCore(separator);
            AppendLineCore();
            AppendCore(enumerator.Current);
        }

        return this;
    }
    #endregion
    #region Append Line
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendLineCore()
    {
        ThrowIfCancellationRequested();

        _ = Options.NewLine.IsString ?
            _builder.Append((String)Options.NewLine) :
            _builder.Append((Char)Options.NewLine);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AppendSingleLineCore()
    {
        if(LastWasNewLine)
            return;

        AppendLineCore();
    }
    public IndentedStringBuilder AppendLine()
    {
        AppendLineCore();
        return this;
    }
    public IndentedStringBuilder AppendLine(String value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine(Char value) => Append(value).AppendLine();
    public IndentedStringBuilder AppendLine<T>(T value)
        where T : IIndentedStringBuilderAppendable
        => Append(value).AppendLine();
    #endregion
    #region ToString & Equality
    public override String ToString() => _builder.ToString();
    public override Boolean Equals(Object? obj) => Equals(obj as IndentedStringBuilder);
    public Boolean Equals(IndentedStringBuilder? other) =>
        other is not null &&
        CollectionEqualityComparer<StringOrChar>.Default.Equals(_indentations, other._indentations) &&
        CollectionEqualityComparer<Block>.Default.Equals(_blocks, other._blocks) &&
        EqualityComparer<StringBuilder>.Default.Equals(_builder, other._builder);
    public override Int32 GetHashCode() =>
        (
            _builder,
            CollectionEqualityComparer<StringOrChar>.Default.GetHashCode(_indentations),
            CollectionEqualityComparer<Block>.Default.GetHashCode(_blocks)
        ).GetHashCode();
    #endregion
    #region Cancellation
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ThrowIfCancellationRequested() => Options.AmbientCancellationToken.ThrowIfCancellationRequested();
    #endregion
}
